{"title":"Fibonacci Heap","content":"Fibonacci Heaps are collections of Leftist Trees . As those collections are part of a linked list, each element of the Fibonacci Heap has a pointer to the next element and a Leftist Tree. A new element is inserted into the top of the linked list at the leftist tree. If the top element's leftist tree and the next element's leftist tree have the same height, then a merge between them is performed. They are so called Fibonacci Heaps due to their frequency of merging. Code snippets Below you will see a Fibonacci Heap with Leftist Trees. public class LeftistTreeNode { public String value; public LeftistTreeNode left; public LeftistTreeNode right; public LeftistTreeNode parent; public LeftistTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class FibonacciHeapNode { public FibonacciHeapNode next; public LeftistTree tree; public FibonacciHeapNode(String value) { this.next = null; tree = new LeftistTree(); tree.insert(value); } } /** * Rules * 1. npl(left) = npl(right) * 2. prio(root) = prio(root.left) = prio(root.right) * Leftist tree is not a search structure, then it allows duplicate values */ public class LeftistTree { public LeftistTreeNode root; /** * Core Functions */ public void insert(String value) { LeftistTreeNode n = new LeftistTreeNode(value); insertLeftistTree(this.root, n); } /** * Insert new node */ private void insertLeftistTree(LeftistTreeNode currentNode, LeftistTreeNode newNode) { if (currentNode == null) { this.root = newNode; this.root.parent = null; } else { merge(currentNode, newNode); } } /** * Lazy merge: joins two left trees */ public void merge(LeftistTreeNode root, LeftistTreeNode newNode) { // Considering the tree.element with largest value on the top if (root.parent == null && root.value.compareTo(newNode.value) leftNpl || (rightNpl == leftNpl && leftValue.compareTo(rightValue) 0) { // invert here to change to small priority on top newRoot = toBeRemoved.left; newRoot.parent = null; merge(newRoot, toBeRemoved.right); this.root = newRoot; } else { newRoot = toBeRemoved.right; newRoot.parent = null; merge(newRoot, toBeRemoved.left); this.root = newRoot; } performSwap(this.root.right); System.out.println(\"\\nElement removed successfully.\"); } } } /** * Helper Functions */ public LeftistTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(LeftistTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Calculating the height of a node according to the root. */ public int heightRootToNode(LeftistTreeNode currentNode) { int height = 0; while (currentNode.parent != null) { height++; currentNode = currentNode.parent; } return height; } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(LeftistTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class FibonacciHeap { public FibonacciHeapNode root; /** * Core Functions */ /** * Insert new node */ public void insert(String value) { FibonacciHeapNode newNode = new FibonacciHeapNode(value); if (this.root == null) { this.root = newNode; } else { newNode.next = this.root; merge(newNode); } } public void find(String s) { int i = 0; FibonacciHeapNode root = this.root; LeftistTreeNode element; if (root != null) { do { element = root.tree.find(s); if (element != null) { System.out.println(\"Element with value \" + s + \" found in node \" + i); break; } i++; root = root.next; } while (root != null); } } /** * Removes the hight priority tree.element. It runs through the list. * */ public void remove() { if (this.root != null) { FibonacciHeapNode beforeHighestPriority = this.root; FibonacciHeapNode root = this.root.next; if (root == null) { this.root.tree.remove(); } else { do { if (beforeHighestPriority.tree.top().value.compareTo(root.tree.top().value) Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","path":"fibonacci-heap","image":"http://i.imgur.com/1mMV9xR.jpg","released":true,"date":"2015-01-14T02:10:11.000Z","github":"https://github.com/LeonardoCardoso/Trees","tags":["java","tree","fibonacci","leftist"]}