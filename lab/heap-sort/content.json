{"title":"Heap Sort","content":"Heap Sort is a comparison-based algorithm and can be considered as an improvement of Selection Sort and like that Selection, it separates the input into to a sorted and an unsorted region, and at each interaction it shrinks the unsorted region by extracting the smallest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the minimum. Both algorithms along with 5 others can be found here . On this post, we use Heap Sort as a application of Priority Queues . That means that we have an unsorted Binary Heap and we use the Heap Sort to make it sorted. See its visualization: Source: Wikipedia Code snippets Below you will see heap sort which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } public class HeapSort { private BinaryHeap binaryHeap = new BinaryHeap(); private ArrayList priorityQueue = new ArrayList (); private Pair[] heapified; /** * Heap sort is simply to inheap the elements to priority queue, and outheap * elements */ public Pair[] sort(Pair[] set) { heapified = new Pair[set.length]; /** Build initial heap */ heapify(set); heapSort(); return heapified; } private void heapify(Pair[] set) { /** Heapifying */ for (int i = 0; i Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Before sorting After sorting Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","path":"heap-sort","image":"http://i.imgur.com/8DJn3OA.jpg","released":true,"date":"2015-01-12T01:56:26.000Z","github":"https://github.com/LeonardoCardoso/Priority-Queue","tags":["priority","queue","java","min","heap","sort","heapsort"]}