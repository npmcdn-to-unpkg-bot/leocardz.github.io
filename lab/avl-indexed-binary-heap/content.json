{"title":"AVL Indexed Binary Heap","content":"This approach is about Upgrade and Downgrade functions. In a normal Binary Heap, Upgrade and Downgrade are O(n) and it's expensive for us, so to improve that we use an AVL Tree to map the items and their positions on the Binary Tree. Thus, we can perform those functions in O(log n). Consider that there are no repeated indexes. Code snippets Below you will see a avl-indexed binary tree which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** value */ public int v; public Pair(int priority, int value) { this.p = priority; this.v = value; } @Override public String toString() { return \"[p=\" + p + \",v=\" + v + \"]\"; } } public class TreeNode { public int value; public TreeNode left; public TreeNode right; public TreeNode parent; public int key; public int balance; public TreeNode(int k, int v) { left = right = parent = null; balance = 0; key = k; value = v; } public TreeNode getLeft() { return left; } public void setLeft(TreeNode left) { this.left = left; } public TreeNode getRight() { return right; } public void setRight(TreeNode right) { this.right = right; } public TreeNode getParent() { return parent; } public void setParent(TreeNode parent) { this.parent = parent; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } } public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public void insert(int key, int value) { TreeNode n = new TreeNode(key, value); insertAvl(this.root, n); } /** Insert new node */ private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nKey \" + newNode.key + \" already exists. Ignoring...\"); } } } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the heaps.tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the heaps.tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } System.out.println(\"Left: \" + l + \" Key: \" + node.key + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } public TreeNode top() { return this.root; } public TreeNode left() { return this.root.left; } public TreeNode right() { return this.root.right; } /** * Calculates the Inorder traversal of this heaps.tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class BinaryHeapAvlIndexed { private AvlTree avlTree; /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeapAvlIndexed() { priorityType = HIGH; avlTree = new AvlTree(); } public BinaryHeapAvlIndexed(int type) { priorityType = type; avlTree = new AvlTree(); } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, 0); } public void swapHeapUpDown(ArrayList priorityQueue, Pair x, int position) { int currentPosition = position; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue.get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue.get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue.get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p + delta; /** Then, reorganize the priority queue over x */ swapHeapDownUp(priorityQueue, priorityQueue.get(pos), pos + 1); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p - delta; /** Then, reorganize the priority queue over x */ swapHeapUpDown(priorityQueue, priorityQueue.get(pos), pos); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Map the heaps.element index at the AVL heaps.tree */ public void map(ArrayList priorityQueue) { for (int i = 0; i priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue.set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } /** Get AvlTree */ public AvlTree getAvlTree() { return avlTree; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: /** Upgrade over the Pair(2, 3) */ binaryHeapAvlIndexed.upgrade(priorityQueue, 50, new Pair(2, 3)); /** Downgrade over the Pair(52, 3) */ binaryHeapAvlIndexed.dowgrade(priorityQueue, 37, new Pair(52, 3)); Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","path":"avl-indexed-binary-heap","image":"http://i.imgur.com/8DJn3OA.jpg","released":true,"date":"2015-01-08T19:05:00.000Z","github":"https://github.com/LeonardoCardoso/Priority-Queue","tags":["priority","queue","java","binary","tree","avl"]}