[{"path":"android-custom-font-without-memory-leak","date":"2013-04-12T03:07:14.000Z","content":"If you want to use custom fonts in your Android app, you have to take note of an issue which might give you a headache: the memory. In this tutorial, you will see two ways to use custom fonts without memory leak, even if you use in a ListView. Well, these two ways are: XML natively and Java programmatically. Before showing these ways, let's see how avoid the memory leak. You create a SingleTon class to host the font file *.ttf you put in assets folder. In this case, open_sans.ttf file. So, there will be one only instance for the custom class. public class OpenSans { private static OpenSans instance; private static Typeface typeface; public static OpenSans getInstance(Context context) { synchronized (OpenSans.class) { if (instance == null) { instance = new OpenSans(); typeface = Typeface.createFromAsset(context.getResources().getAssets(), \"open_sans.ttf\"); } return instance; } } public Typeface getTypeFace() { return typeface; } } Now the two ways... 1. Natively You need to create a classe extending from the view you want to custom the typeface. I used a TextView. public class NativelyCustomTextView extends TextView { public NativelyCustomTextView(Context context) { super(context); setTypeface(OpenSans.getInstance(context).getTypeFace()); } public NativelyCustomTextView(Context context, AttributeSet attrs) { super(context, attrs); setTypeface(OpenSans.getInstance(context).getTypeFace()); } public NativelyCustomTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); setTypeface(OpenSans.getInstance(context).getTypeFace()); } } E and use XML as follows. // <com.leocardz.views.NativelyCustomTextView android:id=\"@+id/natively_text_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_margin=\"20dp\" android:text=\"@string/natively\" android:textSize=\"30sp\" /> 2. Programmatically Just find the view by id and set the new typeface. TextView programmaticallyTextView = (TextView) findViewById(R.id.programmatically_text_view); programmaticallyTextView.setTypeface(Gothic.getInstance(this) .getTypeFace()); That's it!","tags":["Android","Memory Leak","Custom"],"image":"http://i.imgur.com/ggJmoAA.png","title":"Android: Custom Font without Memory Leak","label":"android"},{"path":"android-link-preview","date":"2013-07-30T13:07:28.000Z","content":"This a version for Android of my web Link Preview . How to use with Gradle Simply add the repository to your build.gradle file: repositories { jcenter() maven { url 'https://github.com/leonardocardoso/mvn-repo/raw/master/maven-deploy' } } And you can use the artifacts like this: dependencies { compile 'com.leocardz:link-preview:1.1@aar' // ... } Like the php version, it makes a preview from an url, grabbing all the information such as title, relevant texts and images. It works even with shortened urls, image urls, etc... Watch a video of its work!","tags":["link","preview","google","play"],"image":"http://i.imgur.com/HM8SmKK.png","title":"Android Link Preview","label":"android"},{"path":"animated-expanding-listview","date":"2014-03-04T02:33:26.000Z","content":"Animated Expanding ListView provides a fancy animation on expanding or collapsing the content of a list view item. It works in all version of Android and it's very easy to adapt to your project. How to use with Gradle Simply add the repository to your build.gradle file: repositories { jcenter() maven { url 'https://github.com/leonardocardoso/mvn-repo/raw/master/maven-deploy' } } And you can use the artifacts like this: dependencies { compile 'com.leocardz:aelv:1.1@aar' // ... } Important Your list adapter must extend ArrayAdapter<? whatever ?> Your listview item must extend from AelvListItem Right after you create your listview item, you need to call yourItem.setUp(int collapsedHeight, int currentHeight, int expandedHeight, boolean isOpen); to setup the dimensions. Your listview item view holder must extend from AelvListViewHolder Right after you instantiate your view holder you need to call yourHolder.setViewWrap(viewWrap) ; and tell adapter that you are updating the item size calling holder.getViewWrap().setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT, listItem.getCurrentHeight())); . Right before you return the view on your custom adapter, you must call yourItem.setHolder(yourHolder) ; You need to instantiate Aelv aelv = new Aelv(isAccordion, animationDuration, yourListItems, yourListView, yourAdapter); right after you setup your listview. Last thing: your must implement listview.setOnItemClickListener(); and insert this aelv.toggle(view, position); inside the listener and voilà! Just check the app example to see it clearly. Basically, you have to create a custom TranslateAnimation and a Custom List Adapter and, while it's animating, you have to update the current height of listview item and notify the adapter about this change. Something like that: public class ListItem extends AelvListItem { private String text; private int drawable; public ListItem(String text) { super(); this.text = text; this.drawable = R.drawable.down; } public String getText() { return text; } public void setText(String text) { this.text = text; } public int getDrawable() { return drawable; } public void setDrawable(int drawable) { this.drawable = drawable; } } // This allows Android OS to reuse your item in the list public class ListViewHolder extends AelvListViewHolder { private TextView textView; public ListViewHolder(TextView textView) { super(); this.textView = textView; } public TextView getTextView() { return textView; } public void setTextView(TextView textView) { this.textView = textView; } } public class ListAdapter extends ArrayAdapter { private ArrayList listItems; private Context context; public ListAdapter(Context context, int textViewResourceId, ArrayList listItems) { super(context, textViewResourceId, listItems); this.listItems = listItems; this.context = context; } @Override @SuppressWarnings(\"deprecation\") public View getView(int position, View convertView, ViewGroup parent) { ListViewHolder holder = null; ListItem listItem = listItems.get(position); if (convertView == null) { LayoutInflater vi = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); convertView = vi.inflate(R.layout.list_item, null); LinearLayout textViewWrap = (LinearLayout) convertView.findViewById(R.id.text_wrap); TextView text = (TextView) convertView.findViewById(R.id.text); holder = new ListViewHolder(text); // setViewWrap IS REQUIRED holder.setViewWrap(textViewWrap); } else { holder = (ListViewHolder) convertView.getTag(); } // THIS IS REQUIRED holder.getViewWrap().setLayoutParams(new AbsListView.LayoutParams(LayoutParams.MATCH_PARENT, listItem.getCurrentHeight())); holder.getTextView().setText(listItem.getText()); holder.getTextView().setCompoundDrawablesWithIntrinsicBounds(listItem.getDrawable(), 0, 0, 0); convertView.setTag(holder); // setHolder IS REQUIRED listItem.setHolder(holder); return convertView; } } public class MainActivity extends Activity { private ArrayList listItems; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView listView = (ListView) findViewById(R.id.list); listItems = new ArrayList (); mockItems(); ListAdapter adapter = new ListAdapter(this, R.layout.list_item, listItems); listView.setAdapter(adapter); // Setup // Aelv aelv = new Aelv(true, 200, listItems, listView, adapter); final Aelv aelv = new Aelv(true, 200, listItems, listView, adapter, new AelvCustomAction() { @Override public void onEndAnimation(int position) { listItems.get(position).setDrawable(listItems.get(position).isOpen() ? R.drawable.up : R.drawable.down); } }); listView.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView parent, View view, int position, long id) { aelv.toggle(view, position); } }); } private void mockItems() { final int COLLAPSED_HEIGHT_1 = 150, COLLAPSED_HEIGHT_2 = 200, COLLAPSED_HEIGHT_3 = 250; final int EXPANDED_HEIGHT_1 = 250, EXPANDED_HEIGHT_2 = 300, EXPANDED_HEIGHT_3 = 350, EXPANDED_HEIGHT_4 = 400; ListItem listItem = new ListItem(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"); // setUp IS REQUIRED listItem.setUp(COLLAPSED_HEIGHT_1, EXPANDED_HEIGHT_1, false); listItems.add(listItem); listItem = new ListItem(\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"); // setUp IS REQUIRED listItem.setUp(COLLAPSED_HEIGHT_2, EXPANDED_HEIGHT_2, false); listItems.add(listItem); // ... } } <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/text_wrap\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" > <TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"18sp\" /> </LinearLayout>","tags":["listview","accordion"],"image":"http://i.imgur.com/xImmSY6.png","title":"Animated Expanding ListView","label":"android"},{"path":"audio-preview","date":"2014-05-28T11:37:23.000Z","content":"A simple Android app to stream an audio by url for pre(view|listen)ing it. If you want to stream audio from a URL or URI (the path of the file inside your device), you will need a few steps shown in code below. You must pay attention when using MediaPlayer.release() and MediaPlayer.reset() methods, because they can lead your app to crash. The code below prevents that. public class MainActivity extends ActionBarActivity { private final String URL = \"https://dl.dropbox.com/s/hgcgq510urmgmed/01%20Main%20Title.mp3\"; private MediaPlayer mediaPlayer; private boolean isPlaying; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setUpMediaPlayer(); streamSong(URL); } private void setUpMediaPlayer() { if (mediaPlayer == null) { mediaPlayer = new MediaPlayer(); mediaPlayer.setOnBufferingUpdateListener(bufferingUpdateListener); mediaPlayer.setOnCompletionListener(completionListener); mediaPlayer.setOnErrorListener(errorListener); } } private void streamSong(String url) { if (mediaPlayer != null) { try { mediaPlayer.setDataSource(url); mediaPlayer.setOnPreparedListener(preparedListener); mediaPlayer.prepareAsync(); } catch (Exception e) { e.printStackTrace(); } } } private MediaPlayer.OnPreparedListener preparedListener = new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { if (mediaPlayer != null) { isPlaying = true; mediaPlayer.start(); } } }; private MediaPlayer.OnCompletionListener completionListener = new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { // End of audio isPlaying = false; } }; private MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i2) { // Error: We could stream song preview\" releaseMediaPlayer(); return false; } }; private MediaPlayer.OnBufferingUpdateListener bufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() { @Override public void onBufferingUpdate(MediaPlayer mediaPlayer, int i) { // Buffer started to play } }; private void releaseMediaPlayer() { if (mediaPlayer != null) { try { if (isPlaying) { mediaPlayer.stop(); isPlaying = false; } mediaPlayer.reset(); } catch (Exception e) { e.printStackTrace(); } } } @Override protected void onStop() { releaseMediaPlayer(); super.onStop(); } } Additionally, you will need these permissions to your manifest file: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission android:name=\"android.permission.INTERNET\" /> That's it!","tags":["audio","preview"],"image":"http://i.imgur.com/uhKipcN.jpg","title":"Audio Preview","label":"android"},{"path":"audio-recorder","date":"2014-05-28T12:16:52.000Z","content":"A simple Android app to record an audio. I could reach a high quality recording by combining MPEG_4 format with AAC_ELD enconding. The AAC_ELD is available only from Jelly Bean (SDK 16) and setting encoding bit rate to 96000, buy If you want to use this code below version 16. As Audio Preview , you must pay attention when using MediaPlayer.release(), MediaRecorder.release() and MediaPlayer.reset() methods, because they can lead your app to crash. The code below prevents that. public class MainActivity extends ActionBarActivity { private static final String LOG_TAG = \"AudioRecord\"; private static String root = null; private static String audioPlayerName = null; private static Long millis; private Button recordButton = null; private Button playButton = null; private MediaRecorder recorder = null; private MediaPlayer mediaPlayer = null; private boolean isPlaying = false; private boolean isRecording = false; public MainActivity() { createDirectoriesIfNeeded(); millis = Calendar.getInstance().getTimeInMillis(); audioPlayerName = root + \"/\" + millis + \"audio.mp4\"; } private void createDirectoriesIfNeeded() { root = Environment.getExternalStorageDirectory().getAbsolutePath(); File folder = new File(root, \"AudioRecord\"); if (!folder.exists()) { folder.mkdir(); } File audioFolder = new File(folder.getAbsolutePath(), \"Audio\"); if (!audioFolder.exists()) { audioFolder.mkdir(); } root = audioFolder.getAbsolutePath(); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setUpIds(); setUpListeners(); } private void setUpIds() { recordButton = (Button) findViewById(R.id.record_button); playButton = (Button) findViewById(R.id.play_button); } private void setUpListeners() { recordButton.setOnClickListener(recordClickListener); playButton.setOnClickListener(playClickListener); } private View.OnClickListener recordClickListener = new View.OnClickListener() { public void onClick(View v) { isRecording = !isRecording; onRecord(isRecording); recordButton.setText(isRecording ? R.string.stop_recording : R.string.start_recording); playButton.setEnabled(!isRecording); } }; private View.OnClickListener playClickListener = new View.OnClickListener() { public void onClick(View v) { isPlaying = !isPlaying; onPlay(isPlaying); playButton.setText(isPlaying ? R.string.stop_playing : R.string.start_playing); recordButton.setEnabled(!isPlaying); } }; private void onRecord(boolean start) { if (start) { startRecording(); } else { stopRecording(); } } private void onPlay(boolean start) { if (start) { startPlaying(); } else { stopPlaying(); } } private void startPlaying() { mediaPlayer = new MediaPlayer(); try { mediaPlayer.setDataSource(audioPlayerName); mediaPlayer.setOnCompletionListener(completionListener); mediaPlayer.prepare(); mediaPlayer.start(); } catch (IOException e) { e.printStackTrace(); } } private MediaPlayer.OnCompletionListener completionListener = new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { stopPlaying(); } }; private void startRecording() { recorder = new MediaRecorder(); recorder.setAudioSource(MediaRecorder.AudioSource.MIC); // ACC_ELD is supported only from SDK 16+. // You can use other encoders for lower vesions. recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC_ELD); recorder.setAudioSamplingRate(44100); recorder.setAudioEncodingBitRate(96000); recorder.setOutputFile(audioPlayerName); try { recorder.prepare(); recorder.start(); } catch (IOException e) { e.printStackTrace(); } } private void stopRecording() { if (recorder != null) { recorder.release(); completionRecording(); } } private void stopPlaying() { if (mediaPlayer != null) { mediaPlayer.reset(); completionPlaying(); } } private void reset() { isRecording = false; isPlaying = false; } private void completionRecording() { reset(); recordButton.setText(R.string.start_recording); playButton.setText(R.string.start_playing); playButton.setEnabled(true); } private void completionPlaying() { reset(); playButton.setText(R.string.start_playing); recordButton.setEnabled(true); } @Override public void onPause() { super.onPause(); stopRecording(); stopPlaying(); } @Override public void onStop() { super.onStop(); stopRecording(); stopPlaying(); } } //R.layout.activity_main <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.leocardz.android.audio.recorder.MainActivity\"> <Button android:id=\"@+id/record_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/start_recording\" /> <Button android:id=\"@+id/play_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:enabled=\"false\" android:text=\"@string/start_playing\" /> </LinearLayout> Additionally, you will need these permissions to your manifest file: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> That's it!","tags":["audio","record"],"image":"http://i.imgur.com/d8OUqBq.jpg","title":"Audio Recorder","label":"android"},{"path":"font-awesomed-android","date":"2014-05-10T09:15:06.000Z","content":"Using Font Awesome in any project allows you to make it beautiful and save your time that you would spend creating icons. What if it could be on Android?! How awesome would it be?! Fortunately, it is totally possible! You already know how to use custom fonts learned HERE: Custom Font without Memory Leak , then you need only to make few changes as follows: Add fontawesome.ttf on assets folder; Create FontAwesome class that makes reference to the file on assets folder; Create FontAwesomeTextView that uses FontAwesome as typeface; Create a set of strings referencing each Font Awesome icon; This would be the result!","tags":["custom","font-awesome","fontawesome"],"image":"http://i.imgur.com/S52SoL4.png","title":"Font-Awesomed Android","label":"android"},{"path":"multiple-layout-listview","date":"2014-06-02T06:04:30.000Z","content":"This tutorial is about how to use multiple layouts in listview. Basically, you have to follow these steps: Create the custom layous; Create a custom adapter; Override getViewTypeCount() method in your custom adapter with the amount of layouts you're gonna use in your listview; Override getItemViewType(int position) method also in your custom adapter to return the current item's view type; Additionally, it's essential to use a view holder to avoid memory leaks. Take a look in the code below. First, we create custom layouts. In this case, four types. // even <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff500000\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"match_parent\" android:layout_gravity=\"center\" android:textSize=\"24sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // odd <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff001f50\" android:gravity=\"right\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"28sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // white <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ffffffff\" android:gravity=\"right\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/black\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"28sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // black <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff000000\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"33sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> Then, we create the listview item. In our case, with a string and a type. public class ListViewItem { private String text; private int type; public ListViewItem(String text, int type) { this.text = text; this.type = type; } public String getText() { return text; } public void setText(String text) { this.text = text; } public int getType() { return type; } public void setType(int type) { this.type = type; } } After that, we create a view holder. It's strongly recommended because Android OS keeps the layout reference to reuse your item when it disappears and appears back on the screen. If you don't use this approach, every single time that your item appears on the screen Android OS will create a new one and causing your app to leak memory. public class ViewHolder { TextView text; public ViewHolder(TextView text) { this.text = text; } public TextView getText() { return text; } public void setText(TextView text) { this.text = text; } } Finally, we create our custom adapter overriding getViewTypeCount() and getItemViewType(int position). public class CustomAdapter extends ArrayAdapter { public static final int TYPE_ODD = 0; public static final int TYPE_EVEN = 1; public static final int TYPE_WHITE = 2; public static final int TYPE_BLACK = 3; private ListViewItem[] objects; @Override public int getViewTypeCount() { return 4; } @Override public int getItemViewType(int position) { return objects[position].getType(); } public CustomAdapter(Context context, int resource, ListViewItem[] objects) { super(context, resource, objects); this.objects = objects; } @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder viewHolder = null; ListViewItem listViewItem = objects[position]; int listViewItemType = getItemViewType(position); if (convertView == null) { if (listViewItemType == TYPE_EVEN) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_even, null); } else if (listViewItemType == TYPE_ODD) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_odd, null); } else if (listViewItemType == TYPE_WHITE) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_white, null); } else { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_black, null); } TextView textView = (TextView) convertView.findViewById(R.id.text); viewHolder = new ViewHolder(textView); convertView.setTag(viewHolder); } else { viewHolder = (ViewHolder) convertView.getTag(); } viewHolder.getText().setText(listViewItem.getText()); return convertView; } } And our activity is something like this: public class MainActivity extends ActionBarActivity { private ListView listView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // here, you can create a single layout with a listview listView = (ListView) findViewById(R.id.listview); final ListViewItem[] items = new ListViewItem[40]; for (int i = 0; i adapterView, View view, int i, long l) { Toast.makeText(getBaseContext(), items[i].getText(), Toast.LENGTH_SHORT).show(); } }); } } See it on operation. That's it!","tags":["custom","adapter","layout"],"image":"http://i.imgur.com/iX1w41f.png","title":"Multiple Layout ListView","label":"android"},{"path":"multitouch-test","date":"2012-03-27T02:15:54.000Z","content":"Multitouch Test is a simple app for Android to test the touch of your device. It measures and shows how accurate is the touch of your device, how many touches it supports, and there are some options to personalize the exhibition. After starting, just touch in screen with fingers that they will be recognized by the app. In Options Menu, there are 4 items for customization, they are: Colors Lines Numbers Coordinates Density Rings Vibration Watch a video while of its work!","tags":["touch","google","play"],"image":"http://i.imgur.com/VGvkWzY.png","title":"Multitouch Test","label":"android"},{"path":"silence-please","date":"2013-08-14T19:16:30.000Z","content":"Control the ambient sound by a sound level limit. When it is exceeded, the \"Silence Please\" will alert! Watch a video of its work!","tags":["url","silence","please","google","play"],"image":"http://i.imgur.com/ZZUrAqY.png","title":"Silence Please","label":"android"},{"path":"url-unshortener","date":"2013-08-02T04:12:57.000Z","content":"This is a simple url unshortener. This is the first app implemented with the lib I developed Android Link Preview Watch a video of its work!","tags":["url","unshortener","google","play"],"image":"http://i.imgur.com/vmgsz7e.png","title":"Unshorten It","label":"android"},{"path":"ai-meets-accessibility","date":"2015-11-04T11:06:27.000Z","content":"Facebook's AI team has been doing a significant improvements on their researches. Inspired in biology, the AI network is basically a network of simulated neurons. They teach this virtual mind showing some pictures and telling it what it is. For instance, some pictures of dogs and stating the breed, the AI starts to learn the characteristics of that breed and then it can recognize the dog breed in another picture with the dog in a different position. Their artificial intelligence is about to help people. Now their advances enable their AI to read the images for you. Read?! Yes! The algorithm 'looks' at a picture and say what it may contain. The biggest bottlenecks here are the reliability and the speed on recognizing the photo elements. It's just the start... Regarding accessibility, the reading of images can provided vision-impaired people to picture the picture in their minds. A girl in the video says that only three words help to flash out the details she can't see. What about a whole statement?! It opens a huge door... An extension... An amplification of what we can do! Check out the full video below: I'm inspired by this video about our artificial intelligence research at Facebook.Our AI can now look at a photo,... Posted by Mark Zuckerberg on  Tuesday, 3 November 2015 They are moving towards their goal: Build intelligent machines to help people in their daily lives.","tags":["accessibility","facebook","artificial intelligence","ai"],"image":"http://i.imgur.com/rv9vdmX.gif","title":"When Artificial Intelligence meets accessibility","label":"blog"},{"path":"an-amazing-perspective-of-your-versioned-project-gource","date":"2013-04-16T00:24:40.000Z","content":"See your project flow with other eyes. Gource it. Gource is free and open source software under GNU GPL v3 license that allows you to see the progress of your project by a tree, branchs and leaves. It works in Linux and Windows. Watch a video while it's working! Currently Gource includes built-in log generation support for Git, Mercurial, Bazaar and SVN (as of 0.29). And all requirements you need is OpenGL and a 3D accelerated video card to run. If you are a Linux user o/, you just have to install it via apt-get # apt-get install gource And then go to the root directory of your project and run the following command $ gource Visit the official website of the project Gource here .","tags":["3D","OpenGL","Animation"],"image":"http://i.imgur.com/NyXG3Ju.png","title":"An amazing perspective of your versioned project. Gource.","label":"blog"},{"path":"bitcoin","date":"2015-03-20T17:48:04.000Z","content":"Trade on Internet and its continuous usage increased the demand for quick and easy ways of payment, driving the emergence of online payment systems over the past years. Although there are several of these systems called \"virtual wallets\", all their properties are based on fiat currencies like the real and the gold, that is, physical coins. Thus, almost all transactions made are entrusted to financial institutions, called \"trusted third parties\" for the validation of centralised electronic payments. Bitcoin was designed to be an exception to the these conventional ways. Presented to the world in 2009 by Satoshi Nakamoto, Bitcoin is an independent fully electronic monetary system that has in its own structure based encryption, hashes as identifying unit, irreversible transactions, and the ability to verify and validate their transactions using protocols on a global peer-to-peer network of participants, thus, decentralised and distributed, earning the title of the first cryptocurrency. Despite not being a regulated currency, the acronym BTC is adopted as an international currency code. It is not bound to any governments, fiat currencies or other commodities. It relies on cryptography and protocols to allow transactions to be performed among two parties without going through financial institutions or validator companies of digital signatures named trusted third party. Thus, Bitcoin has the peculiarity of keeping entities' identity anonymously, while its flows is explicit and globally visible. Bitcoins transactions are broadcast to the network and collected into blocks. A transaction references previous transaction outputs, containing addresses which are SHA-256 hashes, as new transaction inputs and dedicates all input Bitcoin values to new outputs. Transactions are not encrypted as said before, so it is possible to browse and view every transaction ever collected into a block. Like the other kinds of money, the number of Bitcoins is finite. Unlike them, one Bitcoin is infinitely divided. So you can divide one fraction of Bitcoin into other infinite fractions. This is why some refer to \"infinite\" divisibility, because the network can select the level that is needed as time goes on. The current level selected in the code (by Satoshi) is 8 decimal places (1 satoshi = 0.00000001 BTC). New bitcoins are generated by the network through the process of \"mining\". Bitcoin miners use a special software to solve math problems in a certain amount of Bitcoins in exchange. This is a way to issue the currency and also it incentives other people to mining. The miners solve these math problems and also verifies the transactions that are being made along the network. As the math problems grow harder, mining pools were created to make a faster mining. Mining pools work like a computer network and each pool miner is rewarded according to the amount of work that he/she provided. Just like a continuous raffle draw, mining nodes on the network are awarded bitcoins each time they find the solution to a certain mathematical problem (and thereby create a new block). Creating a block is a proof of work with a difficulty that varies with the overall strength of the network. The reward for solving a block is automatically adjusted so that, ideally, every four years of operation of the Bitcoin network, half the amount of bitcoins created in the prior 4 years are created. The last block that will generate coins will be block #6,929,999 which should be generated at or near the year 2140. The total number of coins in circulation will then remain static at 20,999,999.9769 BTC. It may seem easy but surprisingly, it's still not easy to buy bitcoins with your credit card or PayPal. This is because such transactions can easily be tracked. First of all, you need to get yourself a Bitcoin wallet. A lot of apps or websites can do it for you because they use Bitcoin API to generate them. Second, there are many websites that work as markets, just like stock exchanges and home brokers, buying and selling Bitcoins. Most of them allow you to convert real money into Bitcoin. Markets Bitcoin Ticker : Tick by tick, real time updates. All data is indicative. Coinbase : Your bitcoin wallet Mercado Bitcoin : Largets market in Latin America Complementary readings Bitcoin Bitcoin Simplified Price Slump Tests Bitcoin’s Self-Correcting Economics Bitcoin: Our Best Tool for Privacy and Identity on the Internet Images: https://bitcoin.org/bitcoin.pdf","tags":["bitcoin","virtual","p2p","peer-to-peer"],"image":"http://i.imgur.com/UVgTCia.png","title":"Bitcoin","label":"blog"},{"path":"google-honors-george-boole","date":"2015-11-02T16:03:52.000Z","content":"Today's Google's doodle is about one great mathematician and one of the greatest contributors to build what we today call it a computer: George Boole. In fact, Modern Computing and Modern Electronics started to be built a long time after 'The Laws of Thinking' — Boole's main work —, like a century after. Would Boole think that his work would be so important?! So important that every little action ~even in binary nerdie stuff~ in computer obeys the Boolean Logic. That's right! It got his name on it! At least that... The boolean value is fundamental for programming languages. This boolean value will tell if something is true or false , so the computer can perform actions based on these commands. Additionally, there are some combinations with true and false which are very largely used, which the Google's Doodle is representing. First take a look and the second G on the doodle, it represents x and y ~ our variables ~, and when the variable is showing its value is true , otherwise is false , let's go to the combinations: AND: for a 'AND' to produce a true value, both variables must be true. In our case, x and y must be true so the first G will be colored, otherwise 'AND' will produce a false value. XOR: for a 'XOR' to produce a true value, only one of the variables must be true. In our case, x must be true or y must be true, not both, so the first O will be colored, otherwise 'XOR' will produce a false value. X stands for exclusive. OR: for an 'OR' to produce a true value, at least one of the variables must be true. In our case, x or y must be true, or both, so the second O will be colored, otherwise 'OR' will produce a false value. NOT: differently of 'AND', 'OR' and 'XOR' that are binary, 'NOT' is an unary operation. For a 'NOT' to produce a true value, the variable must be false, because it's negating the its value. If the variable is true, 'NOT' will produce a false value. In our case, y must be false so the L will be colored, and x must be false so the E will be colored. Here we used only two variables, but those operations can be use with as much as variables you want, like: x AND y AND z AND a... So, because of this important contribution, Google honors the 200 th George Boole's birthday. Well done, Google!","tags":["googe","doodle","boole","boolean"],"image":"http://i.imgur.com/Jkof57C.gif","title":"Google honors George Boole","label":"blog"},{"path":"information-wants-to-be-free-but-which-kind-of-information","date":"2015-03-03T05:56:36.000Z","content":"With the recent personal information leaks, the Stewart Brand's \"Information wants to be free\" resurfaces. But what kind of information is that?! This sentence is linked to another sentence \"Information wants to be expensive\" at the same statement. So it can be understood free referring to price and/or freedom. In fact, unfortunately, generalizing that \"Information wants to be free\" thing doesn't discriminate if this \"information\" is a music file, a part of a book text, or your personal data, credit cards and medical problems. Once information has passed to a new location outside of the source's control there is no way of ensuring it is not propagated further and widely distributed. Personal information must remain private (expensive, on other words), unless the owner wants it to be public. Government's information, such projects, expenditures, partnerships details, must be public because, in the end, the government is people's. And when it's not made public, it leaves an open gap to take advantage in whatever. Private companies' information must remain private. However, from the moment that companies information extend to the people and/or their government, they should be made public. A clear example of these is that news websites charge readers to view content on their pages, or offer some content for free and charge for them beyond the free area. But this type of general information should be public, as they are news that commonly are broadcasted in open television. Additionally, advertisements seems not to be enough for those websites, even more constant than in TV. And that information mostly involves public places or the people directly, such as protests coverage, public parties, etc. Unlike a fully streaming service that the only source of income is the monthly subscription (music, video or books services, for example). Such services need to pay royalties, production, licensing, etc. But even if the series are shared by torrents, it has a huge self-advertisement and much larger than in a paid service. Thus, it ends to cause the person to buy products, including books of which the series are based from. I can tell you that empirically. It is a call of the streaming services to offer better options for people tend to sign in on them. It's fair that they offer a free content and a paid content. But they can not forbid you to listen to their music, watch their series, read their books with the people in your circle. Digital content of common information should be free. In fact, I would say that not only does information want to be free but also the very content is often better when it is free. Not only to readers but also free to publishers. In most of social networks, they are rules about publishing contents. They might violate terms of use. Is it a censorship?! If you are using that service, you may accept their terms, including the removal of some content. This was publicly first contested by Internet pioneer John Gilmore in the pages of TIME Magazine in 1993: \"The Net interprets censorship as damage and routes around it.\". Back then, family-friendly online services used to delete messages they found offensive. Nowadays, those services even have features that the very users can report the content about that violation. And the Net really takes down content that does not fit to their subjective mind. Subjective because what can be offensive to me cannot be offensive to you. I know you probably heard about the Wikileaks-Amazon-Paypal thing. But, is any suppression of content a censorship?! Some things definitely need to be suppressed, removed, such as child pornography, don't you think?! As said by Jerry Brito, in Why Your Personal Information Wants to Be Free , it's better to think as information control rather censorship. We all think about information control somehow, that implies the subjectiveness I talked about. But what John Gilmore said about censorship applies to attempt to control any information online. Additionally, you need to keep in mind that you must be responsible for everything you do online at all circumstances. Because, everybody has access to it of a certain way. In fact, we can't control the information flood. Regarding the software, my thought is Open Source as many others think like me, probably most of us. However, we cannot force companies to open their code, although many companies use free-licensed softwares (or codes) in their background and don't mention them as the code license asks to. There is a mindset that needs to be accepted and received, not imposed. Of course there are things that must be kept secret even in a code like third-party credentials, for example. Despite the good sense, always there will be people trying to invade companies' system and companies trying the close those breaches. Like Stallman, \"I believe that all generally useful information should be free. By 'free' I am not referring to price, but rather to the freedom to copy the information and to adapt it to one's own uses... When information is generally useful, redistributing it makes humanity wealthier no matter who is distributing and no matter who is receiving.\" The Open Source thinking allows the society evolve technologically faster. Complementary readings Why Your Personal Information Wants to Be Free Privacy Matters The Definitive Story of Information Wants to Be Free Information wants to be free ... and expensive Information Wants To Be Free Entrepreneurs Must Defend Intellectual Property Rights","tags":["information","activism"],"image":"http://i.imgur.com/cwPQFSr.png","title":"'Information Wants to Be Free'... But which kind of information?","label":"blog"},{"path":"open-source-swift","date":"2015-12-04T15:42:16.000Z","content":"Apple got everyone surprised at this year's WWDC when they disclosed that Swift would be open source. They did it yesterday! They released Swift on GitHub under Apache 2.0 License . Ok, but you must be asking what do I have to do with it?! If you are a final client, perhaps you won't notice such difference of an app built in Swift or another programming language. But if you are a developer and not familiar with this language, you will find it kinda fascinating and more intuitive than other languages. Swift makes things simpler. And that can affect the final user, apps being built faster with a better performance. On my personal experience, from the scratch of an app to its publishing on Apple Store took about 14 days, including Store's revision process. You can check it out here . For me, this is the natural order of scaling a product and make it more reliable to the developers and customers: Open Source. The advantages of an open source product is the flexibility that allows developers that are not inside the box to solve the issues, because they can show better solutions and the community stands together, thousands of new people inside that code, with more confidence over the language. But can it spoil the code? Well, that's why the standards of contributing exist for those kinda of stuff. Tests must be run to check that changes won't bring back past issues. There's is a control. This is a huge step for Apple, the first step ~I'm sure~, sometimes criticized for being closed in its own product world. Soon, we'll be seeing Swift softwares on Windows, Linux, Android(?), etc. Hopefully you are as anxious as I do.","tags":["apple","swift","open source"],"image":"http://i.imgur.com/U7TuUhm.png","title":"Apple's Swift now is open source! Ok, now what?!","label":"blog"},{"path":"privacy-matters","date":"2015-03-18T16:44:55.000Z","content":"We live in an era of mass surveillance. And things don't seem to change in an early future. Information is valuable and they pay (mi|bi)llions for that. But in a privacy-free world, only moulded and conditioned people would live. Our behaviour changes dramatically when we know that we are being watched. How many times have you seen \"Smile, you're being watched!\" inside lifts or places with a CCTV system?! The range of free thought and action about the options we have around reduces because we think how those people who are watching are analysing us. For us, developers, we don't like being watched when they are programming. Creativity leaks down. In Brazil, we have this expression that most parents or adult relatives say to their kids: \"Olha que Papai do céu está te vendo!\". It can be roughly translated to \"Watch out because God (heavenly Father) is looking at you\". But it kinda sounds more like a threat for the kid to behave. It reminds Google's slogan \"Don't be evil\". It's absolutely wrong to think that only a person evolved to bad activities wants some privacy. They usually says that \"because if you are not doing anything wrong, you don't need to worry about.\". Is that so?! No reason to fear that huge companies and the Government are monitoring you and your family, all the time?! For them, only those who confront power might be worried of privacy, which is not true. In fact, our information becomes valuable for companies that live mostly with ads. Their machines learn about our lifestyle by our information and they can target specific ads for us. Apple claims that it's not use our data for ads, since their business doesn’t depend on advertising. Unlike Google and Facebook that have targeted advertising as their largest incoming source. The more they know about us, the more they earn. No one wants a Big Brother of George Orwell's 1984 around! Everyone wants a little privacy. This video is an great speech given by the journalist Glenn Greenwald who helped Edward Snowden's disclosures of classified files. His work on the NSA files was in part the subject of the film Citizenfour, which won the 2014 Academy Award for Best Documentary. This next video is how our data should be stored at the companies' servers.","tags":["privacy","information","activism"],"image":"http://i.imgur.com/cwPQFSr.png","title":"Privacy matters","label":"blog"},{"path":"pull-requests-you-better-use-them","date":"2015-02-01T10:47:35.000Z","content":"Pull requests are a feature that many of repository hosting service provides such GitHub and Bitbucket . It is a better way of submitting contributions to a project using a distributed version control system such as Git or Mercurial and easier for developers to collaborate. It is important to highlight that PRs are a workflow feature , and not a feature of the version control system itself. And pull requesting occurs when a developer asks for changes committed to an external repository, often the local repository and a different branch from the branch you want to pull request to, to be considered for inclusion in a project’s main repository. PRs are basically a mechanism for a developer to tell team members that he/she has completed a feature and it’s ready to be included often on other branch by merging. Thus, all team members are notified of a new PR and can inspect it and merge it, including you ~ but it's not a good practice ~ . Generally, the hosting services provide a complete forum showing all info about the changes, who did it, why did it... PR flow is basically: You made changes on your branch and pull it to your respective branch on remote repository Then, on its hosting service there is a link to create a pull request where you choose the repo which is the source of the modifications and the destination. The team members, not you , analyse your modifications, discuss them, alter them, aprove them. When all is ok, the project maintainer merges it. PR is closed. Below is an real example of one of my repo in GitHub: Facebook Link Preview . Some developers has forked my repo and pull-requested to it. List of pull requests Pull request flow Pull request commit Here are two links to know about them: GitHub pull requests Bitbucket pull requests","tags":["git","mercurial","scm"],"image":"http://i.imgur.com/s6WXbc9.png","title":"Pull Requests: you better use them.","label":"blog"},{"path":"three-of-my-android-apps-just-got-their-source-code-opened","date":"2015-02-12T02:25:25.000Z","content":"I've decided to open the code of three of my apps that are on Google Play: Multitouch Test, Unshorten It, Silence Please. Now, those contents are free under APACHE 2.0 License, so you can download it, study it, modify it at your will. Help the community! Engage yourself! Multitouch Test :: Google Play :: GitHub Unshorten It :: Google Play :: GitHub Silence Please :: Google Play :: GitHub","tags":["google","play","android","open","source"],"image":"http://i.imgur.com/GDUlJzz.png","title":"Three of my Android apps just got their source code opened","label":"blog"},{"path":"what-is-algorithm","date":"2012-03-09T14:10:15.000Z","content":"If you search the web the definition of algorithm, the more frequent answer is \"An algorithm is a finite sequence of instructions defined and unambiguous, each of which can be performed in a finite period of time and a finite amount of effort. \". This is just a basic idea. If perhaps you've never heard that word, know that for sure you practiced it at some point in your life. Have you ever cooked?! If yes, you followed the recipe steps to have the desired food, or at least it was meant to be. The fact is that if the sequence of steps is not followed as it is written in recipe, the end result can not be as the expected one. What if you have to hang out... Do you put on your shoes before the socks and then wear the pants? Such steps aren't really good, it's not a good idea. And this algorithm can be performed in three different ways that will produce the same outcome, can you perceive that? But these examples are simple, for there are much more complex algorithms, and others algorithms exist only in theory. Huh?! How so?! Just keep reading... Perhaps Algorithm is the most used term in the of Computing area. But it doesn't represent a specific computer program. It may have its implementation and execution on a computer, a mechanical machine, another automata, and until, of course, by people like the examples shown above. Different algorithms can accomplish the same task using a different set of instructions which may result in more or less expenditure of time, space or effort. And these attributes are related to the computational complexity that was applied to the algorithm and that depends directly on the data structure that was built into it. It is obvious that if you put your socks and shoes and then wear the pants that will take longer and be more work than you wear the pants first. Two different algorithms, but they will produce the same result. There are several ways to represent an algorithm more formally, some of them are a flowchart, coding and automata. Even more specific types of algorithm, such as neural, natural, sort, search, encryption, meta-heuristics, quantum, and many others. In the future, they will have their own post here. On what was talked about only theoretical algorithms, was an example that can be given is the Traveling Salesman Problem (TSP), that is an optimization problem of finding the route of least effort in which the Salesman visit exactly once all the cities and then return to your original city, but precisely it's about to find the lowest cost across all nodes of a weighted graph. The computational effort required to solve this problem grows exponentially in scale in relation to the given input (number of cities). In Analysis of Algorithms, it belongs to a class called NP-hard or NP-complex. Thus, since it is difficult, or even impossible, to determine optimal solution of this class of problems, methods of resolution that go through the heuristics that, in the mathematical point of view, do not ensure obtaining an optimal solution, but try to approximate the much as possible the optimal resolution. This was a brief idea about what is algorithm but remember, the algorithm is not ~ algarithm ~ (there is no such word, but people insist to say that), even less algarism... Image: Marshall Clemens","tags":["Algorithm"],"image":"http://i.imgur.com/UOZVOxe.png","title":"What is Algorithm?","label":"blog"},{"path":"what-terminal-is-leo-using","date":"2016-06-09T11:04:54.000Z","content":"Paraphrasing Felix Krause's setup repo , here is some information about the setup I'm currently using. I use iTerm2 instead of the stock terminal Mac app I use oh-my-zshell I use Solarized Dark for the terminal colors I use powerline-shell to get those cool path bars. I use powerlevel9k theme to easily customise the shell. This is my currently customisation I use the Meslo Powerline Font as you need a font that supports the directory characters for powerline I use z an amazing tool to quickly jump between projects. It learns which directories you visit most and autocomplete their path on the terminal I use a set of aliases for git and you can check them at GitAliases I use TermHere to open a terminal on a specific folder from Finder. I just changed the Terminal App option on its configuration to open iTerm2 instead stock Mac terminal.","tags":["terminal","iterm2","zsh","oh-my-zsh"],"image":"http://i.imgur.com/zrFGeVY.png","title":"What terminal is Leo using","label":"blog"},{"path":"why-children-should-learn-how-to-code-early","date":"2015-10-26T13:48:04.000Z","content":"Everybody that uses Internet daily is using thanks to the developers and designers around the world. If it wasn’t by their work, we’d be stuck in the past. If you are one of the people who think that programming is a kind of magic or another world’s stuff, for others it seems more something seamlessly natural, passionate, intuitive, and even pleasant. But how?! Have you ever noticed how much kids love stories?! From the movies or books… When they ask you to read for them?! That’s right! If you think about a movie and its components, you will find out the screenplay, the director, the actors, the production, the scenarios, etc… All those components you may also find in programming! For example, the screenplay is detailed idea to be developed, the director may be the product owner, the actors are the developers, the production is the resources you have to program and the tracking of the whole process of programming, the scenarios are the small parts of the big idea. Wait, wait, wait! In fact, these terms are about a complete software process and really technical for children, they can assimilate this naturally though, just like they learn a new language that’s totally different from that which they speak, learn how to ride a bicycle, learning how to swim. Nobody starts programming knowing building all those stuff. We don’t learn to ride a bicycle without training wheels first. We do start easily. In programming, we start with Algorithm . An algorithm is a finite sequence of instructions defined and unambiguous, each of which can be performed in a finite period of time and a finite amount of effort. An algorithm is a finite sequence of instructions defined and unambiguous, each of which can be performed in a finite period of time and a finite amount of effort. In other words, an algorithm is some steps you do before something. Think about the bike. You mount the bike, prepare the pedal and push it down, so the bike starts moving. The steps you did are in favor of the goal, which is moving the bike. Not always the goal is reached by only one algorithm though. Thinking about swimming, if your goal is to cross the pool, you can use different styles to do it, some faster, some less tiring… Can you think about other way to cause the bike to move besides the example I gave? The algorithm is the main component of programming along with Mathematical Logic . With them, you will be able to learn any existing programming language. Some adjusts may be necessary from programming language to language, just like the spoken languages. But the core, the communication, is the same. Ok, but why should the children learn how to program?! Well, the kids have the ability to learn faster and more than the others, and coding is as beneficial as music lessons. The evolving process of their brains expand. They will be able to solve problems more naturally and faster, break complex problems into smaller ones, divide and conquer. They will know how to use abstraction, think outside the box. Additionally, they got in contact with mathematics more often. The triple combination is the basis of Computer Science: Mathematics, Logic and Algorithm. That’s our main tools to solve problems. The kids will learn the Computation Thinking . Computational thinking is the thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information-processing agent. Research Notebook: Computational Thinking — What and Why? I was born in ’90. I grew up seeing the technology a thousand faster than my parents did, and I’m sure that our future kids will see computers billions of times faster than we do. It’s the science fiction coming true. The children of the mid of ‘2000 already were born in world totally connected, they don’t even know what is rewinding a VHS video tape. But you can’t force a child to program, you need to incentive him/her. If he/she likes a game, you can ask if he/she would want to know how a game is made, how a robot moves, and so on… The very own interest and curiosity about technology is even better to welcome them to the Matrix. The idea that the children can use their own imagination to build what they want is ideal to boost interest on them. To show them that they can use tech to make something useful to a lot of people. Once you know how to code, you can create virtual worlds within the computer where the only limit on what is possible is your imagination. Why every child should learn to code And if we can do what we can do now, just imagine what we would be doing if all of those programmers around the world started in their childhood. We’d be some years ahead from our current time technologically speaking. Additionally, you don’t need to introduce a programming language to a child in the first place. There are several projects that introduce the concepts nicely to the children, such LEGO Mindstorms Everybody in this country should learn how to program a computer… Because it teaches you how to think. Steve Jobs Just check out what Bill, Mark, Jack and others also think about it:","tags":["early","programming","kids","children"],"image":"http://i.imgur.com/CJ0pSoR.jpg","title":"Why children should learn how to code early","label":"blog"},{"path":"infiniteblocks","date":"2015-08-14T00:19:37.000Z","content":"I'm going on an adventure!!! I always wanted to explore the world of making games. And this is my first game. It's a Tetris-like open-source game made in Swift and based in Swiftris . It's addicting!","tags":["iOS","games"],"image":"http://i.imgur.com/KZnxPNp.png","title":"InfiniteBlocks!","label":"ios"},{"path":"swift-link-preview","date":"2016-06-22T18:10:27.000Z","content":"I gotta confess that I got obsessed on trying to port my first Link Preview project to other platforms. I made it! First to Android , then a reboot using newer technologies and now it's on Swift! That's right! Swift is a great programming language that allows us to learn faster and build more stuff in less time because of its simplicity. Back then when I created my first project related to previewing link only Facebook used this feature on their services. Now many companies preview links inside their products. But none of them has open-sourced it. It basically does the same thing as the others. It makes a preview from an URL, grabbing all the information such as title, relevant texts and images. Requirements and Details iOS 8.0+ / macOS 10.9+ / tvOS 9.0+ / watchOS 2.0+ Xcode 7.3 or above Built with Swift 2.2.1 Installation CocoaPods To use SwiftLinkPreview as a pod package just add the following in your Podfile file. source 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0' target 'Your Project Name' do use_frameworks! // ... pod 'SwiftLinkPreview', '~ 0.1.4' // ... end Carthage To use SwiftLinkPreview as a Carthage module package just add the following in your Cartfile file. // ... github \"LeonardoCardoso/SwiftLinkPreview\" ~ 0.1.4 // ... Swift Package Manager To use SwiftLinkPreview as a Swift Package Manager package just add the following in your Package.swift file. import PackageDescription let package = Package( name: \"Your Target Name\", dependencies: [ .Package(url: \"https://github.com/LeonardoCardoso/SwiftLinkPreview.git\", majorVersion: 0) ] ) Manually You just need to drop SwiftLinkPreview folder into Xcode project (make sure to enable \"Copy items if needed\" and \"Create groups\"). Usage Instatiating import SwiftLinkPreview // ... let slp = SwiftLinkPreview() Requesting preview slp.preview( \"Text containing URL\", onSuccess: { result in print(\"\\(result)\") }, onError: { error in print(\"\\(error)\") } ) result is a dictionary [String: AnyObject] like: [ \"url\": \"original URL\", // NSURL \"finalUrl\": \"final ~unshortened~ URL.\", // NSURL \"canonicalUrl\": \"canonical URL\", // NSURL \"title\": \"title\", // String \"description\": \"page description or relevant text\", // String \"images\": [\"array of URLs of the images\"], // String array \"image\": \"main image\" // String ] Cancelling a request slp.cancel() Flow Important You need to set Allow Arbitrary Loads to YES on your project's Info.plist file. License The MIT License (MIT) Copyright (c) 2016 Leonardo Cardoso Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":["iOS","link-preview","swift"],"image":"http://i.imgur.com/IVKMwTw.jpg","title":"Swift Link Preview","label":"ios"},{"path":"veetral","date":"2015-05-14T07:18:54.000Z","content":"Photo collage made easy 1. Choose your grid style: You tell how many pieces your veetral will have choosing between grids. 2. Select the pieces: Tap in the squares you want to snap first and hit the camera button. 3. Complete the photo: Do the same of the second step until the whole picture is done. 4. Share it as you like: Use your social medias or private messaging to your friends and family or just save it to your Camera Roll.","tags":["iOS","camera"],"image":"http://i.imgur.com/ti4rgYl.png","title":"Veetral","label":"ios"},{"path":"7-sorting-algorithms-in-a-few-lines","date":"2013-10-04T00:57:07.000Z","content":"So we will start it from the simplest ones to the hardest ones. Bubble Sort private static void bubbleSort(int[] v) { int i, j, n = v.length; for (i = 0; i v[j]) { swap(v, i, j); } } } } Selection Sort private static void selectionSort(int[] v) { int i, j, min, n = v.length; for (i = 0; i v[j]) min = j; } swap(v, min, i); } } Insertion Sort private static void insertionSort(int[] v) { int i, j, temp, n = v.length; for (i = 1; i = 0 && v[j] temp) { v[j + 1] = v[j]; j--; } v[j + 1] = temp; } } Shell Sort private static void shellSort(int[] v) { int n = v.length; int range = n / 2; int i, j, temp; int gap; while (range 0) { for (i = range; i = range && v[gap] temp) { v[j] = v[gap]; j -= range; gap = j - range; } v[j] = temp; } range /= 2; } } Heap Sort private static void heapify(int[] v, int pos, int n) { int low = 2 * pos + 1; int high = 2 * pos + 2; int largest, temp; if (low v[pos]) largest = low; else largest = pos; if (high v[largest]) largest = high; if (largest != pos) { temp = v[largest]; v[largest] = v[pos]; v[pos] = temp; heapify(v, largest, n); } } private static void heapSort(int[] v) { int n = v.length, i; int low = n / 2 - 1, high = n - 1; // Build initial heap for (i = low; i = 0; i--) { heapify(v, i, n); } for (i = high; i 0; i--) { swap(v, 0, i); heapify(v, 0, i); } } Quick Sort // Start with quickSort(v, 0, v.length - 1); private static int i; private static int j; private static void partition(int[] v, int low, int high) { i = low; j = high; int x = v[(i + j) / 2]; while (i x) j--; if (i i) quickSort(v, i, high); } Merge Sort // Start with mergeSort(v, 0, v.length - 1); private static void merge(int[] v, int low, int middle, int high) { int[] vAux = new int[v.length]; for (int i = low; i Swap Method private static void swap(int[] v, int i, int j) { int temp = v[i]; v[i] = v[j]; v[j] = temp; }","tags":["sorting","sort","Java","algorithm"],"image":"http://i.imgur.com/yEK4JxE.png","title":"7 Sorting Algorithms in a Few Lines","label":"lab"},{"path":"annotationsoff","date":"2015-03-23T14:31:34.000Z","content":"You must find those text bubbles on Youtube videos boring just like me. So, this lightweight Chrome Extension was developed to remove all unwanted annotations and cards in Youtube videos making them clean and more pleasant to see. Enjoy it! The latest release you will always find it available on Chrome Web Store AnnotationsOff . Those are examples how it looks like with and without annotations and cards:","tags":["chrome","extension","youtube"],"image":"http://i.imgur.com/CgYWr8r.png","title":"AnnotationsOff","label":"lab"},{"path":"avl-indexed-binary-heap","date":"2015-01-08T19:05:00.000Z","content":"This approach is about Upgrade and Downgrade functions. In a normal Binary Heap, Upgrade and Downgrade are O(n) and it's expensive for us, so to improve that we use an AVL Tree to map the items and their positions on the Binary Tree. Thus, we can perform those functions in O(log n). Consider that there are no repeated indexes. Code snippets Below you will see a avl-indexed binary tree which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** value */ public int v; public Pair(int priority, int value) { this.p = priority; this.v = value; } @Override public String toString() { return \"[p=\" + p + \",v=\" + v + \"]\"; } } public class TreeNode { public int value; public TreeNode left; public TreeNode right; public TreeNode parent; public int key; public int balance; public TreeNode(int k, int v) { left = right = parent = null; balance = 0; key = k; value = v; } public TreeNode getLeft() { return left; } public void setLeft(TreeNode left) { this.left = left; } public TreeNode getRight() { return right; } public void setRight(TreeNode right) { this.right = right; } public TreeNode getParent() { return parent; } public void setParent(TreeNode parent) { this.parent = parent; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } } public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public void insert(int key, int value) { TreeNode n = new TreeNode(key, value); insertAvl(this.root, n); } /** Insert new node */ private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nKey \" + newNode.key + \" already exists. Ignoring...\"); } } } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the heaps.tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the heaps.tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } System.out.println(\"Left: \" + l + \" Key: \" + node.key + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } public TreeNode top() { return this.root; } public TreeNode left() { return this.root.left; } public TreeNode right() { return this.root.right; } /** * Calculates the Inorder traversal of this heaps.tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class BinaryHeapAvlIndexed { private AvlTree avlTree; /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeapAvlIndexed() { priorityType = HIGH; avlTree = new AvlTree(); } public BinaryHeapAvlIndexed(int type) { priorityType = type; avlTree = new AvlTree(); } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, 0); } public void swapHeapUpDown(ArrayList priorityQueue, Pair x, int position) { int currentPosition = position; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue.get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue.get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue.get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p + delta; /** Then, reorganize the priority queue over x */ swapHeapDownUp(priorityQueue, priorityQueue.get(pos), pos + 1); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p - delta; /** Then, reorganize the priority queue over x */ swapHeapUpDown(priorityQueue, priorityQueue.get(pos), pos); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Map the heaps.element index at the AVL heaps.tree */ public void map(ArrayList priorityQueue) { for (int i = 0; i priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue.set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } /** Get AvlTree */ public AvlTree getAvlTree() { return avlTree; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: /** Upgrade over the Pair(2, 3) */ binaryHeapAvlIndexed.upgrade(priorityQueue, 50, new Pair(2, 3)); /** Downgrade over the Pair(52, 3) */ binaryHeapAvlIndexed.dowgrade(priorityQueue, 37, new Pair(52, 3)); Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","binary","tree","avl"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"AVL Indexed Binary Heap","label":"lab"},{"path":"avl-tree","date":"2015-01-13T22:28:02.000Z","content":"An AVL tree is balanced binary search tree. Its name contains the letters of its inventors, Adelson-Velskii and Landis, it was the first dynamically balanced tree to be proposed. The AVL trees may not be perfectly balanced, but pairs of sub-trees differ in height by at most 1, keeping an O (log N) search time. Addition and deletion operations also take O (log N) time. The following propositions define an AVL Tree: The subtrees of every node differ in height by at most one. Every subtree is an AVL tree. Search : Searching for a specific element in an AVL Tree can be done the same way as that of a normal unbalanced Binary Search Tree, that is: The searching starts by examining the root node. If the tree is null, the key we are searching for does not exist in the tree. Otherwise, if the key equals that of the root, the search is successful and we return the node. If the key is less than that of the root, we search the left subtree. Similarly, if the key is greater than that of the root, we search the right subtree. This process is repeated until the key is found or the remaining subtree is null. If the searched key is not found before a null subtree is reached, then the item must not be present in the tree. It can be a recursive or an iterative process. Insertion process is like the search; if the key is not equal to that of the root, we search the left or right subtrees as before. Eventually, we will reach an external node and add the new key-value pair as its right or left child, depending on the node's key. In other words, we examine the root and recursively insert the new node to the left subtree if its key is less than that of the root, or the right subtree if its key is greater than or equal to the root. After inserting a node, it is necessary to check each of the node's ancestors for consistency with the rules of Avl. And it is measured by the Balance Factor. The balance factor is calculated as follows: balanceFactor = height (left subtree) - height (right subtree). As the tree is balanced at every insertion (if necessary), the height of an AVL subtree cannot increase by more than one, so the temporary balance factor of a node will be in the range from âˆ’2 to +2. f the balance factor becomes less than âˆ’1 or greater than +1, the subtree rooted at this node is unbalanced, and rotations are necessary to make the tree balanced again. Rotations are operations that change the structure without interfering with the order of the elements. A tree rotation moves one node up in the tree and one node down. It is used to change the shape of the tree. The AVL Tree has 4 types of rotations: Right rotation : consists in rearranging clockwisely the positions of two nodes. Left rotation : consists in rearranging anticlockwisely the positions of two nodes. Right-Left rotation (AKA Double Right) : consists in rearranging clockwisely (first rotation) and anticlockwisely (second rotation) the positions of three nodes. Left-Right rotation (AKA Double Left) : consists in rearranging anticlockwisely (first rotation) and clockwisely (second rotation) the positions of three nodes. Sometimes a single rotation is not sufficient to balance an unbalanced tree, that's why the double rotations are needed. The first and second rotations are not performed on the same node. Source: Wikipedia Deletion : Like Insertion, the Deletion is similar to the Search. For deleted leaf nodes, clearly the heights of the children of the node do not change. Also, the heights of the children of a deleted node with one child do not change either. Hence, if a deletion causes a violation of the AVL Tree height property, this will occur on some node on the path from the parent of the deleted node to the root node. To restructure the tree after a deletion we will call the restructure method on the parent of the deleted node. Code snippets Below you will see a AVL Tree. public class TreeNode { public String value; public TreeNode left; public TreeNode right; public TreeNode parent; public int balance; public TreeNode(String v) { left = right = parent = null; balance = 0; value = v; } } public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** * Core Functions */ /** * Insert new node */ public void insert(String value) { TreeNode n = new TreeNode(value); insertAvl(this.root, n); } private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.value.compareTo(currentNode.value) 0) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nValue \" + newNode.value + \" already exists. Ignoring...\"); } } } /** * Finds a node */ public TreeNode find(String key) { currentSearchHeight = -1; return find(this.root, key); } /** * Finds a node */ public TreeNode find(TreeNode currentNode, String value) { currentSearchHeight++; if (value.equals(currentNode.value)) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (value.equals(currentNode.value)) return currentNode; else if (value.compareTo(currentNode.value) 0) return find(currentNode.right, value); else if (currentNode.left != null) return find(currentNode.left, value); else return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree */ public void remove(String k) { currentSearchHeight = -1; removeAvl(this.root, k); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, String searchingKey) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); } else { if (startingNode.value.compareTo(searchingKey) 0) { removeAvl(startingNode.left, searchingKey); } else if (startingNode.value.compareTo(searchingKey) = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { String l = \"0\"; String r = \"0\"; String p = \"0\"; if (node.left != null) { l = node.left.value; } if (node.right != null) { r = node.right.value; } if (node.parent != null) { p = node.parent.value; } System.out.println(\"Left: \" + l + \" Value: \" + node.value + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } public TreeNode top() { return this.root; } public TreeNode left() { return this.root.left; } public TreeNode right() { return this.root.right; } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","tags":["java","tree","avl"],"image":"http://i.imgur.com/1mMV9xR.jpg","title":"AVL Tree","label":"lab"},{"path":"binary-heap","date":"2015-01-08T18:21:56.000Z","content":"A binary heap is a complete binary tree which follows the heap ordering property, that is all nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison rule defined. By design, there are two approaches of ordering that can be applied: min-heap: each element's priority ≥ its parent's priority. The minimum priority stands on the top. max-heap: each element's priority ≤ its parent's priority. The maximum priority stands on the top. Here, we consider the highest element on the top. Insertion is performed the last level and the last position of the heap. After that, the new element is compared to its parent and if there is inconsistency with their order, a rearrangement is made by changing positions of the child and the parent by using the method swapHeapDownUp . This task is done until it hits the root. Deletion is always performed at the top of the heap. The root element is popped out. The vacant root is taken by the element with the last element of the last level. Then, the new top element is compared with its two children and, if necessary, the replacement is performed changing the root with one of its children with the method we particularly called swapHeapUpDown and the last step is performed again. Upgrade and Downgrade: those functions increase or decrease the priority inside the elements, reorganizing the heap if necessary. Code snippets Below you will see a binary tree which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","binary","heap"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"Binary Heap","label":"lab"},{"path":"closed-hashing","date":"2013-10-13T18:31:52.000Z","content":"Collision resolution by Closed Hashing, also know as open addressing. Open Hashing can be considered a good strategy to resolve collisions, but the negative point is the need of an additional cost of memory to store the linked lists. On the other hand, Closed Hashing strategy allows all key-pair values to be stored in the hash table itself, then no extra cost of memory is needed. Collision Let's consider the insertion operation. The algorithm used it's logic (in our case, key modulus size table ) to find a empty slot (bucket), if the slot is not empty, than the algorithm keeps on searching an empty slot using a probe sequence until a free bucket is found or there's no empty slot anymore. The most used probe sequences are: inear probing - distance that the algorithm uses to search a new empty slot is constant (i.e. 1, the next slot); Quadratic probing - distance is current probe ² (i.e. 1² = 1, 2² = 4, 3² = 9...) and current probe lower than or equal to table size ; Double hashing - distance is calculated using another hash function; Rehashing - distance is calculated using linear or quadratic probing. But to grant that the key-pair value will be inserted, this approach uses a threshold. When this threshold is reached, the size of hash table is increased to the closest prime number of the double of its size. And all current key-pair values are arranged in the new size of the hash table before the new one is inserted. Linear probing Removal operation There are several nuances, when removing a key from hash table with open addressing. Consider following situation: Let's analyse. \"Andrew Wilson\" key has the same calculus of \"Jack Williams\" key, then the next slot the algorithm searched was the next one, but \"Sandra Miller\" key occupied that slot by calculus, then the algorithm searched the next slot, and finally it was empty and \"Jack Williams\" key was rearranged over there. If algorithm simply frees \"Sandra Miller\" slot, the structure of the table will get broken because the algorithm won't succeed trying to find \"Andrew Wilson\" key, since it uses the probe sequence . The slot contains different key and linear probing algorithm will try to find \"Andrew Wilson\" in the next slot, but it is empty, the reference was loss as you can see: The solution is as following. Instead of just erasing the key, the algorithm writes a special key-pair (-1, -1) value to the slot to flag that slot as DELETED. Now lookup algorithm will work properly. Insertion algorithm should reuse deleted slots, when possible: This algorithm resolves the problem, but with time hash table will become clogged with \"DELETED\" entries, which badly affects performance. If hash table should allow items removal, then Open Hashing is more preferable way to resolve collisions. Complexity analysis We call Load Factor the number that represents the complexity of a hash table. We can measure that simply as follows: number of entries / table size . If load factor exceeds 0.7 threshold, table's speed drastically degrades. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class ClosedHashingLinear { private final static int TABLE_INITIAL_SIZE = 8; private Node[] table; public ClosedHashingLinear() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = TABLE_INITIAL_SIZE) { /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); while (table[hash] != null && runner = TABLE_INITIAL_SIZE) { /** Not found */ } else { table[hash] = DeletedNode.getUniqueDeletedNode(); /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Code below implements quadratic probing. And also this implementation is protected against entering infinite loop. public class ClosedHashingQuadratic { private final static int TABLE_INITIAL_SIZE = 7; private Node[] table; public ClosedHashingQuadratic() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = edge) { /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); int edge = (int) Math.ceil((double) TABLE_INITIAL_SIZE / 2); while (table[hash] == null && runner = edge) { /** Not found */ } else { table[hash] = DeletedNode.getUniqueDeletedNode(); /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 18 will produce the following result: Linear 0. [31] 1. [55] 2. [37] 3. [ ] 4. [ ] 5. [23] 6. [24] 7. [6] 8. [42] 9. [ ] 10. [28] 11. [29] 12. [66] 13. [13] 14. [13] 15. [68] 16. [52] 17. [13] Quadratic 0. [ ] 1. [55] 2. [37] 3. [66] 4. [31] 5. [23] 6. [24] 7. [6] 8. [ ] 9. [ ] 10. [42] 11. [28] 12. [29] 13. [13] 14. [13] 15. [68] 16. [52] 17. [13] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Secondary images http://www.algolist.net/Data_structures/Hash_table/Open_addressing","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Closed Hashing","label":"lab"},{"path":"colorblinding","date":"2015-03-23T14:31:33.000Z","content":"Nowadays, accessibility is a frequent topic when technology is talked about. And this matter has always interested me, how technology can be used to make things better for all. Because according to Colour Blind Awareness , some of the types of color blindness affects approximately 1 in 12 men and 1 in 200 women in the world. So, I did a little research about how the websites are made to attend also a color vision impaired person and the different kinds of color blindness. Researching along, I've found some websites which allow us to upload a picture and see how they look like for a color vision impaired person, but not the website itself. So, It came up onto my mind \"What if we could apply filters on the website?!\". Fortunately, it's possible using SVG. The filters are made in SVG with the matrices of each filter corresponding to each color blindness, so the browser can multiply the values. The filters are applied to the website using CSS3 and jQuery. The matrices were calculated from here and SVG original file from here . After the researching, I started to make this Chrome Extension that displays in real time how your website can be seen by them, including images and videos. Colorblinding is working with the following types: Red-Blind / Protanopia Green-Blind / Deuteranopia Blue-Blind / Tritanopia Red-Weak / Protanomaly Green-Weak / Deuteranomaly Blue-Weak / Tritanomaly Monochromacy / Achromatopsia Blue Cone Monochromacy Note1: If the website already uses a filter in its css, the elements might change their original location when applying Colorblinding. To get them back, just select the option deactivate and refresh the page if it doesn't do it by itself. Note2: Colorblinding works in all tabs and the filter is applied when the tab is fully loaded . The latest release is always available on the Chrome Web Store Colorblinding . Those are examples how it looks like:","tags":["accessibility","chrome","extension"],"image":"http://i.imgur.com/iK49vgq.png","title":"Colorblinding","label":"lab"},{"path":"double-hashing","date":"2013-10-13T22:23:17.000Z","content":"Collision resolution by Double Hashing. This strategy uses a second hash function to find a new empty slot in hash table. Like linear probing, it uses one hash value as an initial point and then repeatedly steps forward an interval until an empty slot is reached, or the entire table has been searched; but this interval is decided using a second, independent hash function (that's why its name is double hashing). Nevertheless, depending on the two hash functions that you create, the hash table cannot be completely mapped. And still If load factor exceeds 0.7 threshold, the hash table speed drastically degrades. The implementation below works as follows: The algorithm tries to insert the key into the hash table using its full size as parameter. If the key cannot be inserted, the analysis of the hash table size is changed to the prime number less than its size, and so on... Example: 17, 13, 11, 7, 5, 3, 2. In this case, 2 is the stop criteria for the tries. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class PrimeNumbers { public static int findClosestPrimeNumber(int number) { int previous = 0; int next = 0; for (int i = 0; i number) { int rangeDown = Math.abs(PRIME_NUMBERS[previous] - number); int rangeUp = Math.abs(PRIME_NUMBERS[next] - number); if (rangeDown number) { return PRIME_NUMBERS[previous]; } } else break; } return number; } /** Some prime numbers */ private static final int[] PRIME_NUMBERS = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209 }; } public class ClosedHashingDouble { private final static int TABLE_INITIAL_SIZE = 17; private Node[] table; public ClosedHashingDouble() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = TABLE_INITIAL_SIZE || (table[hash] != null && table[hash].getKey() != key && secondValue == 2)){ /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); int secondValue = TABLE_INITIAL_SIZE; while (table[hash] == null || (table[hash] != null && (table[hash].getKey() != key)) && runner = TABLE_INITIAL_SIZE || (table[hash] != null && table[hash].getKey() != key && secondValue == 2)){ /** Not found */ } else { table[hash] = null; /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 17 will produce the following result: 0. [68] 1. [52] 2. [ ] 3. [37] 4. [55] 5. [ ] 6. [6] 7. [24] 8. [42] 9. [ ] 10. [23] 11. [28] 12. [29] 13. [13] 14. [31] 15. [66] 16. [ ] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Main image: http://www.algolist.net/Data_structures/Hash_table/Chaining","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Double Hashing","label":"lab"},{"path":"facebook-link-preview-php--jquery","date":"2012-10-07T01:09:40.000Z","content":"Disclaimer: I will no longer maintain this project because it's an old code and hard to maintain, but it's exported to AngularJS and Bootstrap. I believe this a great solution for an easy comprehension of the code and will allow the project to evolve even further. You can found this new project here >> Link-Preview All of us know about the big phenomenon that Facebook is. And since they have always to keep inovating, new super interesting features appear. And the liking of Facebook Link Preview is almost unanimous, it's activated when some url is inserted in the field where you update your status. Ok, it's cool But, have ever you stop to think how that works?! I did. And I got too curious. So, I started looking how to build one of it in PHP + Javascript , using jQuery , and could work like Facebook's and Google+ 's and it can checked out in the example below. As the most important part of the algorithm is in PHP, that is server-side, the capacity of servers that it will run can influence the speed of its execution. And we do not even have to comment about the giants' servers, since they are ones of the biggest technology companies in the world. The algorithm keeps tracking what you are typing in the status field and through regular expressions identifies a url. Thereafter, the text is in the field is passed to PHP that does all the work to analyze all the source code of the url found. If you enter more than one url, it will consider that the first one is the more relevant and it will create a preview. Once the source code of the url is obtained, regular expressions begin to seek out and capture relevant information on it. This information is basically the title page, the images contained therein, and a brief description of the content covered in the page. From the collection of information is assembled the page preview. I didn't speak more about the details of the code, giving examples of implementation, because the Link Preview is intrinsic to insert a url and generate the preview, but for developers who want to go further exploring the code, I'm providing the download of files with only one request: keep my reference in the codes, right?! I hope you enjoy! How to added onto your project Important: Make sure the library php5-curl is installed and enabled on the server, either locally or remotely. - Linux $ sudo apt-get install php5-curl $ sudo service apache2 restart - Mac (via macports ) $ sudo port install php5-curl $ sudo apachectl restart 1 • Scripts <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'</script <script src='js/linkPreview.js' </script <!-- If you are saving and fetching results from database using FLP, you can customize the layout on this script -- <script src='js/linkPreviewRetrieve.js' </script 2 • Stylesheets <!-- This stylesheet is provides the layout of Facebook’s former textarea. You can totally customize this! -- <link rel=\"stylesheet\" type=\"text/css\" href=\"css/linkPreview.css\" / 3 • Configuration Just create your own textarea (or multiple textareas) and bind it to jQuery like this: <script $(document).ready(function() { $('#lp1').linkPreview(); // changing placeholder $('#lp2').linkPreview({placeholder: \"Second Field\"}); // bind to a tag the results brought from database $('#retrieveFromDatabase').linkPreviewRetrieve(); }); </script Result Format { \"title\":\"title\", \"url\":\"original url\", \"pageUrl\":\"page url\", \"canonicalUrl\":\"cannonical url\", \"description\":\"description\", \"images\": \"img1|img2|...\", \"video\":\"yes|no\", \"videoIframe\":\"video iframe if it is video\" } Options option default value possible values function imageQuantity -1 any integer set the max amount of images to be brought (-1 for illimited) placeholder What's in your mind any string set the placeholder of textarea","tags":["Facebook","Link Preview","PHP","jQuery"],"image":"http://i.imgur.com/XqaYUvI.png","title":"Facebook Link Preview: PHP + jQuery (no longer maintained)\r\n","label":"lab"},{"path":"fibonacci-heap","date":"2015-01-14T02:10:11.000Z","content":"Fibonacci Heaps are collections of Leftist Trees . As those collections are part of a linked list, each element of the Fibonacci Heap has a pointer to the next element and a Leftist Tree. A new element is inserted into the top of the linked list at the leftist tree. If the top element's leftist tree and the next element's leftist tree have the same height, then a merge between them is performed. They are so called Fibonacci Heaps due to their frequency of merging. Code snippets Below you will see a Fibonacci Heap with Leftist Trees. public class LeftistTreeNode { public String value; public LeftistTreeNode left; public LeftistTreeNode right; public LeftistTreeNode parent; public LeftistTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class FibonacciHeapNode { public FibonacciHeapNode next; public LeftistTree tree; public FibonacciHeapNode(String value) { this.next = null; tree = new LeftistTree(); tree.insert(value); } } /** * Rules * 1. npl(left) = npl(right) * 2. prio(root) = prio(root.left) = prio(root.right) * Leftist tree is not a search structure, then it allows duplicate values */ public class LeftistTree { public LeftistTreeNode root; /** * Core Functions */ public void insert(String value) { LeftistTreeNode n = new LeftistTreeNode(value); insertLeftistTree(this.root, n); } /** * Insert new node */ private void insertLeftistTree(LeftistTreeNode currentNode, LeftistTreeNode newNode) { if (currentNode == null) { this.root = newNode; this.root.parent = null; } else { merge(currentNode, newNode); } } /** * Lazy merge: joins two left trees */ public void merge(LeftistTreeNode root, LeftistTreeNode newNode) { // Considering the tree.element with largest value on the top if (root.parent == null && root.value.compareTo(newNode.value) leftNpl || (rightNpl == leftNpl && leftValue.compareTo(rightValue) 0) { // invert here to change to small priority on top newRoot = toBeRemoved.left; newRoot.parent = null; merge(newRoot, toBeRemoved.right); this.root = newRoot; } else { newRoot = toBeRemoved.right; newRoot.parent = null; merge(newRoot, toBeRemoved.left); this.root = newRoot; } performSwap(this.root.right); System.out.println(\"\\nElement removed successfully.\"); } } } /** * Helper Functions */ public LeftistTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(LeftistTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Calculating the height of a node according to the root. */ public int heightRootToNode(LeftistTreeNode currentNode) { int height = 0; while (currentNode.parent != null) { height++; currentNode = currentNode.parent; } return height; } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(LeftistTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class FibonacciHeap { public FibonacciHeapNode root; /** * Core Functions */ /** * Insert new node */ public void insert(String value) { FibonacciHeapNode newNode = new FibonacciHeapNode(value); if (this.root == null) { this.root = newNode; } else { newNode.next = this.root; merge(newNode); } } public void find(String s) { int i = 0; FibonacciHeapNode root = this.root; LeftistTreeNode element; if (root != null) { do { element = root.tree.find(s); if (element != null) { System.out.println(\"Element with value \" + s + \" found in node \" + i); break; } i++; root = root.next; } while (root != null); } } /** * Removes the hight priority tree.element. It runs through the list. * */ public void remove() { if (this.root != null) { FibonacciHeapNode beforeHighestPriority = this.root; FibonacciHeapNode root = this.root.next; if (root == null) { this.root.tree.remove(); } else { do { if (beforeHighestPriority.tree.top().value.compareTo(root.tree.top().value) Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","tags":["java","tree","fibonacci","leftist"],"image":"http://i.imgur.com/1mMV9xR.jpg","title":"Fibonacci Heap","label":"lab"},{"path":"genetic-algorithm","date":"2013-10-28T08:17:37.000Z","content":"A genetic algorithm (GA) is a very interesting and useful technique to find solutions for complex problems. These algorithms have that name because they are based in the behaviour of the genes, natural selection, mutation and crossover. They're commonly used to design computer algorithms to solve other optimization problems. Genetic algorithms work by mimicking the way life finds solutions to real world problems using the process of evolution. Although genetic algorithms are capable of solving incredibly complicated problems, they are way simple to understand. Candidate - Set a candidate solutiona, the optimum value. Initialization - Create an initial population with random individuals and each one with its own genetic code. Evaluation - Each member of the population is then evaluated and we calculate a 'fitness' for that individual. The fitness is calculated by how many similarities that the current individual, in analysis, have compared to the Candidate. Selection - For constantly improving the population's overall fitness, the best individuals must be selected for crossover and, then, create a new population closer to the Candidate. Crossover - During crossover we create new individuals by creating crosses of our selected individuals, the parents. The combination of these parents will create an even 'fitter' offspring for the next population which inherits the best genes of both individuals. Mutation - After the crossover, the mutation replaces some genes in the new individual. Otherwise, every combination in crossover will be the initial population, then the fitness would remain the same every evolution. And repeat it until find the optimum solution! Individual public class Individual { private byte[] genes = new byte[Main.defaultGeneLength]; private int fitness = -1; /** Create a random individual */ public void generateIndividual() { for (int i = 0; i Population public class Population { Individual[] individuals; /** Create a new population */ public Population(int populationSize, boolean initialize) { individuals = new Individual[populationSize]; /** * Initialize the population when it is not a population in evolving * process */ if (initialize) { /** Create the individuals */ for (int i = 0; i Fitness public class Fitness { static byte[] solution = new byte[Main.defaultGeneLength]; /** Set a candidate solution as a byte array */ public static void setSolution(byte[] newSolution) { solution = newSolution; } /** * Covert a candidate solution as a string to a candidate solution as a byte * array */ public static void setSolution(String newSolution) { solution = new byte[newSolution.length()]; /** * Run along the string converting its char as a byte */ for (int i = 0; i Algorithm public class Algorithm { /** Rate for maintaining of the originality */ private static final double uniformRate = 0.5; /** Rate allowed to mutate */ private static final double mutationRate = 0.015; /** Tournament set size */ private static final int tournamentSize = 5; /** Keep the fittest individual each evolution */ private static final boolean elitism = true; /** Evolve population */ public static Population evolvePopulation(Population population) { Population newPopulation = new Population(population.size(), false); /** * If elitism is wanted, then the best individual of this population * must be keeped */ int elitismOffset; if (elitism) { newPopulation.welcomeIndividual(0, population.getFittest()); elitismOffset = 1; } else elitismOffset = 0; /** Create a crossover in population individuals */ for (int i = elitismOffset; i Considering an initial population with 50 individuals and a genetic code 011101100000, the result in my machine was: Candidate Solution: 011101100000 **Initial Generation** Generation: 1 Fittest: -1 Genetic Code: 001001000100 Generation: 2 Fittest: 9 Genetic Code: 011101001100 Generation: 3 Fittest: 10 Genetic Code: 001111100000 Generation: 4 Fittest: 11 Genetic Code: 011001100000 **Optimum Solution** Generation: 5 Fittest: 12 Genetic Code: 011101100000 Idea derived and optimized from http://www.theprojectspot.com/tutorial-post/creating-a-genetic-algorithm-for-beginners/3","tags":["genetic","ga","algorithm","java"],"image":"http://i.imgur.com/a2yW2cH.png","title":"Genetic Algorithm","label":"lab"},{"path":"git-actual-guide-with-actual-examples","date":"2015-01-30T18:52:37.000Z","content":"Git is a free distributed revision control system for source code management (SCM). It is open source and designed to increase the speed and the efficiency on distributed and non-linear workflow projects. Additionally it improves its data integrity. You can download it from git-scm.com/downloads . First things first On Git world, you need to get used to some terms that will come up frequently. They are: repository : also shortened as “repo”, it's a directory where your project code will be managed and versionized. It can be local to a folder on your computer or it can be a storage space on an online host. commit : it's a command that create a \"snapshot\" of the current state of your repository in time, giving you a checkpoint to which you can analyse or restore your project to any previous state (other commits). commit hash : it's a SHA1 hash linked to a commit working as its id. Although its 40-digit-long size, you only need the 4 or 6 first chars to refer it. branch : branches are separate areas of development where you can work without interfering to each other. It's by this way that Git is collaborative. There's at least one branch in your repo and you should never work in a repository which other person is working on. You create a branch for you instead. staging area or index : a cache of files that you want to commit. An area where files added to index are enrolled. staged files: files prepared for a commit, added to index unstaged files: files not prepared to commit, not added to index. working directory : the root folder where you perform your coding. working copy : the folders and files that you’re currently using. It's always local. snapshot : it's a \"time registration\" of your project in time created by a commit. A \"version\". history : it's a \"book\" that contains everything of all the registrations of your project since your gitted it. Customizing Git configuration: git config This command allows you to configure your Git installation globally or on an individual repository. It can define from user info to preferences to the behavior of a repository. Below you'll find the most used git config commands. git config user.name <name and git config --global user.email <email define author's info that will be shown on commits and logs. $ git config --global user.name Leonardo Cardoso $ git config --global user.email leo@leocardz.com You also can create a shortcut to git command (e.g. 'git stage' as 'git add'). git config --global alias. $ git config --global alias.stage add $ git config --global alias.co commit $ git config --global alias.cane \"commit --amend --no-edit\" git co will work as git commit . You can choose your preferred editor. Git 's default one is vi . git config --global core.editor <editor Setting Sublime Text as default. $ git config --global core.editor \"subl -n -w\" Every next editing thing will be open on your preferred editor. Creating a repo: git init [--bare] To create a repository with a working directory where you can actually work, you simply need to use this command inside the directory: $ git init Initialized empty Git repository in ~/git_101/.git/ After creating it you will see that the directory contains a .git folder where all the git stuff goes and you will work at the level where the .git folder is. Bare repository is a git repository without a working directory, so you can’t work on it. Typically, when you are on a server, you have no need to have a working directory. Additionally, bare repositories are usually central repositories where all collaborators move their work to. It's a way to synchronize efforts between multiple people. $ git init --bare Initialized empty Git repository in ~/git_101_bare/ Cloning an existing repo: git clone [--bare] <repo [<directory] This command is similar to git init , but it clones a repo instead of creating one. Additionally, it creates a remote called 'origin' for the repo cloned from, sets up a local branch based on the remote's active branch (generally master), and creates remote-tracking branches for all the branches in the repo. $ mkdir git_102 $ git clone git_101 git_102 Cloning into 'git_102'... done. It works for bare repos as well: $ mkdir gg $ git clone --bare git@github.com:LeonardoCardoso/mvn-repo.git gg Cloning into bare repository 'gg'... remote: Counting objects: 24, done. remote: Compressing objects: 100% (11/11), done. remote: Total 24 (delta 1), reused 24 (delta 1) Receiving objects: 100% (24/24), 282.70 KiB | 125.00 KiB/s, done. Resolving deltas: 100% (1/1), done. Checking connectivity... done. Adding files to staging area: git add <file Let's create the file new_file.txt . It has to be created inside the working directory where you initialised git. git add <file $ vi new_file.txt $ git add new_file.txt By this doing, our new_file.txt is at the staging area and ready to be committed. To add all files that are not staged, use: $ git add . Removing files from staging area: git rm [--cached] <file To remove a file from staging area and/or tracking, use git rm [--cached] <file . $ git rm new_file.txt Caution: to remove all files, use: $ git rm . To remove file from version control and keep it in the working repository, use git rm --cached <file . $ git rm --cached new_file.txt Committing a file: git commit [-m] [<message] Committing a file is to tell Git to create a snapshot of the state of you project. All your added, modified, removed files since the last commit will have their status updated with this new commit. A message can be added to describe briefly what was changed. Let's commit our new_file.txt that we have already added: git commit -m <message $ git commit -m \"Initial commit\" [master (root-commit) 13abdd5] Initial commit 1 file changed, 1 insertion(+) create mode 100644 new_file.txt You also have the option to open your editor on commit. Just use: git commit $ vi .gitignore $ git add . gitignore $ git commit Editor will open. So you can add your message... .gitignored added # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # Changes to be committed: # new file: .gitignore # [master 44e0174] .gitignored added 1 file changed, 1 insertion(+) create mode 100644 .gitignore .gitignore: A special file .gitignore is a file that Git always looks before its commands. There you can tell git which files are not (and will be not) tracked. It's a simple text file and you can use regular expressions to block more than one file at once, like $ vi .gitignore Editor will open. So you can add your files which won't be tracked anymore... thisFileWillBeIgnored.txt # file ignored dir/ # entire directory ignored anotherDir/starting* # only files that start with \"starting\" inside anotherDir will be ignored *.jar # all jar files will be ignored If a file is already being tracked, you need to remove it, so it won't be tracked anymore. Otherwise, it will keep being tracked. Editting a commit: git commit --amend [[-m <message] [--no-edit]] This command is extremely useful because it allows you to change last commit info such as message or even adding or removing files. But, be aware! If your commit has already been pushed to remote repo, you have to force-pushing. You will learn about it later... If you noticed in our commit 13ab (hash), we added a message \".gitignored added\", but we want to change this message because the real name of the file is .gitignore. We can do it as follows: $ git commit --amend Your editor will open and you can change the message to “.gitignore added”, save it and close. [master 85c2310] .gitignore added 1 file changed, 1 insertion(+) create mode 100644 .gitignore You also can edit it inline using git commit --amend -m <message $ git commit --amend -m \".gitignore added\" [master 1d5a33b] .gitignore added 1 file changed, 1 insertion(+) create mode 100644 .gitignore If something was forgotten and you changed them but you don't want to change the commit message, you can do it using git commit -amend --no-edit . Showing details of a commit: git show <commit This command shows the details of a commit, like what files were added, modified and what was modified, removed. In our case, I created .gitignore file with the text \"thisFileWillBeIgnored.txt\". $ git show 85c2 commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added diff --git a/.gitignore b/.gitignore new file mode 100644 index 0000000..79591b7 --- /dev/null +++ b/.gitignore @@ -0,0 +1 @@ +thisFileWillBeIgnored.txt Viewing only the files that were changed in the last commit: git show --pretty=\"format:\" --name-only <commit git show --pretty=\"format:\" --name-only c158503 README Status of a repository: git status If you want to see the current status of the current branch your project, you can use git status to show that like listing which files are staged, unstaged, and untracked. git status lets you inspect the working directory and the staging area. $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) new_file2.txt nothing added to commit but untracked files present (use \"git add\" to track) Logging: git log This command displays committed snapshots and all their info. With it, you can list the project history, filter it, and search for specific changes. In contrast to git status , git log only operates on the committed history. $ git log commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added commit 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Author: Leonardo Cardoso <leo@leocardz.com> Date: Fri Jan 23 13:36:05 2015 +0000 Initial commit Showing changed files, just add --stat : $ git log --stat commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added .gitignore | 1 + 1 file changed, 1 insertion(+) commit 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Author: Leonardo Cardoso <leo@leocardz.com> Date: Fri Jan 23 13:36:05 2015 +0000 Initial commit new_file.txt | 1 + 1 file changed, 1 insertion(+) To shorten the messages excluding the empty lines, you can use git log --stat --oneline : $ git log --stat --oneline 85c2310 .gitignore added .gitignore | 1 + 1 file changed, 1 insertion(+) 13abdd5 Initial commit new_file.txt | 1 + 1 file changed, 1 insertion(+) Show messages formatted, just use --pretty=oneline. It also works for git show. $ git log --pretty=oneline 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit If you want to format a commit to a .patch file like to attach to an email, just use it: git format-patch -1 <commit $ git format-patch -1 85c2 0001-.gitignore-added.patch Showing who committed the staged file: git blame <file Git lets you show who manipulated a file by using git blame command. $ git blame new_file.txt 13abdd5 (Leonardo Cardoso 2015-01-23 13:36:05 +0000 1) First file Showing author's email instead the author's name: $ git blame -e new_file.txt 76a33985 (<leo@leocardz.com> 2015-01-26 01:27:05 +0000 1) Second file To show the changes in a subset of commits using hashes: $ git blame 76a3..13ab new_file.txt 13abdd5 (Leonardo Cardoso 2015-01-23 13:36:05 +0000 1) First file If the file is big, you can use regular expressions to know who included some block of code in it. $ git blame newest_file.txt 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 1) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 2) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 3) foo (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 4) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 5) } 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 6) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 7) bar (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 8) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 9) } 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 10) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 11) main (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 12) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 13) } $ git blame -L/^main/,/^}/ newest_file.txt 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 11) main (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 12) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 13) } Note: git blame only works on staged files. $ git blame thisFileWillBeIgnored.txt fatal: no such path 'thisFileWillBeIgnored.txt' in HEAD List branch files: git ls-files If you are a Unix-based SO user you certainly are familiar to ls command, or dir for Windows users. To list the files of the current branch, use the following command: $ git ls-files .gitignore new_file.txt newest_file.txt Viewing differences between two commits in a file: git diff git diff shows changes between commits, commit and working tree, etc. $ git diff diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. git diff HEAD shows the differences between the working directory and the most recent commit: $ git diff HEAD diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. If you added the files, but still want to view the difference to the last commit, git diff --cached lets you to see that. It shows difference between the staging area (index) and the last commit: $ git diff --cached diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. Viewing differences between two commits in a file: git diff <hash..<hash <file $ git diff 76a3..13ab new_file.txt diff --git a/new_file.txt b/new_file.txt index 20d5b67..4c5fd91 100644 --- a/new_file.txt +++ b/new_file.txt @@ -1 +1 @@ -Second file +First file Creating branches: git branch One of the most important things on Git is branches. When you create a new branch, it will have the same history and files of the current branch which you created the one from unless you specify the commit. To create a new branch, just type: git branch <branch $ git branch developer To list branches, just use: git branch The * indicates the current branch your project is. $ git branch developer * master To list all branches, local and remote, just use: git branch -a $ git branch -a developer * master remotes/origin/developer remotes/origin/master To go to the new branch, just use: git checkout <branch $ git checkout developer Switched to branch ‘developer' To create a new branch from specified commit, just use: git checkout <branch <commit $ git branch new_branch_name 0aa034c Delete a branch: git branch -d <branch To delete a branch is simple: git branch -d <branch $ git branch -d developer Deleted branch developer (was 48f97a4). To force deletion, use a capital \"D\": git branch -D <branch Adding a remote repo: git remote This command lets you create, view, and delete connections to other repositories. It's most used to add the bare repository of your local repository. git remote add origin <path $ git remote add origin ../git_init_bare $ git remote add origin https://github.com/LeonardoCardoso/Movement.git To change the origin path of a already set origin, you can use the following command: git remote set-url origin <path $ git remote set-url origin ../git_101_bare To check the origin, just use: $ git remote -v origin ../git_101_bare (fetch) origin ../git_101_bare (push) Pushing to a repo: git push <remote <branch Pushing to a repo means to send all your local committed modifications to remote branch that you specify. It can be done by the following command: git push <remote <branch $ git push origin master Counting objects: 12, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (12/12), 1010 bytes | 0 bytes/s, done. Total 12 (delta 1), reused 0 (delta 0) To ../git_101_bare/ * [new branch] master - master You can also force a push by using one of the two commands: git push <remote <branch --force or git push -f <remote <branch $ git push origin master -f Warning: force-pushing will overwrite the remote branch with the state of your local one. If there are commits on remote branch that you don't have in your local branch, you will lose those commits. Warning: be cautious about amending commits that you have already shared with other people. Amending commits essentially rewrites them. So they will have different hashes, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to re-synchronize their work with your newly re-written commit, which can sometimes be difficult. So, although the usefulness of amending, avoid to do that if you shared the previous one with other Fetching a branch: git fetch <remote [<remote branch] [:<local branch] This command imports commits from a remote repository into your local repo. The resulting commits are stored as remote branches instead of the normal local branches. To fetch all branches from the origin repo. git fetch <remote $ git fetch origin Same as the above command, but only fetch the specified branch: git fetch <remote <remote branch $ git fetch origin developer If you want to fetch a branch and automatically create a local branch linked to it, use: git fetch <remote <remote branch:<local branch $ git fetch origin developer:dev From ../git_101_bare * branch developer - FETCH_HEAD Our last example will create a local branch named dev that links to developer . If you do not add the local branch on git command (:<local branch) , the branch will be fetched to your local repo as a remote branch, but no working copy branch will be created to link that. Pulling a branch: git pull <remote <branch git pull does a git fetch followed by a git merge . As told before, you can use git fetch at time you want to update your remote-tracking branches under refs/remotes/<remote. It won't affect your working copy though. However, if there is an update on a remote branch and your working copy branch is not up to date with the new modifications, but you want to bring the updates and automatically merge it, you can simply use: git pull <remote <branch $ git pull origin developer From ../git_101_bare * branch developer - FETCH_HEAD Already up-to-date. Merging branches: git merge <branch git merge is design to join two or more development histories together. To merge them, you can use: git merge <branch $ git checkout master $ git merge developer Updating 40bcf0d..9e97315 Fast-forward file_on_dev_branch.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file_on_dev_branch.txt The file we created on developer branch is brought to master branch. Manipulating Multiple Commits: git rebase This command allows you to edit multiple commits messages or join commits. The command is git rebase -i <commit . But, instead of using the commit hash, you can use HEAD~<number of commits that will show the previous N commits before the most recent one. For example: $ git rebase -i HEAD~3 $ git rebase -i 9e97 pick 40bcf0d newest_file.txt added pick 9e97315 Filed added on Dev branch pick 18b2e67 File on third branch # Rebase 76a3398..18b2e67 onto 76a3398 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out When you use this command, the commit you chose is selected. And all of the commits before it is listed and some explanations too. For example, we want to change the commit message of 9e97315. So, we only need to change the word pick at left side of 9e97315 to reword and save the file. After that, you file editor will be open to change the message. reword 9e97315 Filed added on Dev branch A new file added on Developer branch # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 76a3398 # You are currently editing a commit while rebasing branch 'third' on '76a3398'. # # Changes to be committed: # new file: file_on_dev_branch.txt # [detached HEAD b0c6af7] A new file added on Developer branch 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file_on_dev_branch.txt Successfully rebased and updated refs/heads/developer. To check, let's log. $ git log --pretty=oneline 0648d95242ff6ea5705b344aa0c86f6d956d8888 One more file on dev b0c6af74e252828ae8b44791f5787b9f78ce3b6a A new file added on Developer branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit To join commits, you use squash . And the commit you will squash will be meld to the previous commit. And so will their changes. pick 85c2310 .gitignore added pick 76a3398 Changed content new_file.txt squash 40bcf0d newest_file.txt added pick b0c6af7 A new file added on Developer branch pick 0648d95 One more file on dev # Rebase 13abdd5..0648d95 onto 13abdd5 When you save the file, the file editor will be prompted. # This is a combination of 2 commits. # The first commit's message is: Changed content new_file.txt # This is the 2nd commit message: newest_file.txt added # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 13abdd5 # You are currently editing a commit while rebasing branch 'developer' on '13abdd5'. # # Changes to be committed: # modified: new_file.txt # new file: newest_file.txt # Here we removed those two commit messages and we put the message \"Squashed commit\" instead and save it. Squashed commit # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 13abdd5 # You are currently editing a commit while rebasing branch 'developer' on '13abdd5'. # # Changes to be committed: # modified: new_file.txt # new file: newest_file.txt # $ git log --pretty=oneline 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Revert to a previous Git commit using git revert This command undoes a committed snapshot. But, instead of removing the commit from the project history, it undoes the changes introduced by the commit and appends a new commit. This prevents Git from losing history, which is important for the integrity. $ git log --pretty=oneline dd0562dfca2fecf5c938857689a24a40fcb304ae Merge branch 'developer' of ../git_101_bare into developer 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit $ git revert 18b2 [developer 0494017] Revert \"File on third branch\" 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 file.txt $ git log --pretty=oneline 04940178e51e297cd577eab608a417850c430949 Revert \"File on third branch\" dd0562dfca2fecf5c938857689a24a40fcb304ae Merge branch 'developer' of ../git_101_bare into developer 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Revert to a previous Git commit using git checkout This command allows to checkout a branch (showed previously), paths to the working tree or take the branch to some commit in history. git checkout <commit $ git log --pretty=oneline 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit $ git checkout e6b0 HEAD is now at e6b0e3a... A new file added on Developer branch $ git log --pretty=oneline e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Undoing accidental deletions $ git checkout -f Force Git to overwrite local files: git reset If you want to throw out all of the changes you've been working on, you can use: $ git reset --HARD [<commit] If you don't insert the commit, it will be reseted to the most recent commit on remote. $ git reset --HARD 18b2 HEAD is now at 18b2e67 File on third branch $ git log --pretty=oneline 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Stashing modifications: git stash Stashing is a great way to pause what you’re currently working on and come back to it later. Suppose that we are making some changes and we are not done yet, but someone needs urgently that we fix some thing in some previous commit. So we can freeze our local modifications using: git stash $ git add . $ git stash Saved working directory and index state WIP on developer: 8178777 Merge branch 'developer' HEAD is now at 8178777 Merge branch 'developer' So, the files go back to state on the most recent commit on tracking. After we do the fixes, we just need to use git stash list to visualize the existing stashes. $ git stash list stash@{0}: WIP on (no branch): 2ff5a4e One more file on dev And to apply we use git stash apply stash@<stash number $ git stash apply stash@{0} On branch developer Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: one_more_file_on_dev.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") We can quickly apply the last stash using git stash pop . With this command, the applied stash is also deleted. Cleaning up untracked files: git clean Files may pile up in your working directory that are left over from merges, generated, or even put mistakenly there. No matter what, you don't need to ignore them in .gitignore, you just need to remove them. This command dries up the current branch. The following command will list the files to be removed: git clean -n -d <path $ git clean -n -d -x Would remove .DS_Store Would remove thisFileWillBeIgnored.txt The command to clean is git clean -i -d -x $ git clean -i -d -x Would remove the following items: .DS_Store thisFileWillBeIgnored.txt *** Commands *** 1: clean 2: filter by pattern 3: select by numbers 4: ask each 5: quit 6: help What now 1 Removing .DS_Store Removing thisFileWillBeIgnored.txt Bringing specific commit to current branch: git cherry-pick Cherry picking in git means to choose a commit from one branch and apply it onto another. So there is no need to merge the entire branch. Make sure you are in the right branch to cherry-pick the commit from another. git cherry-pick <commit-hash $ git cherry-pick 45fd Finished one cherry-pick. [master]: created 567ed1: “README file.\" 1 file changed, 1 insertions(+), 0 deletions(-) create mode 100644 README.txt Tagging releases: git tag Tags are used for creating stable releases. To do that, simply use the following code: git tag <version $ git tag 1.0 $ git push --tags Counting objects: 7, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 417 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To ../git_101_bare/ * [new tag] 1.0 - 1.0 $ git tag 2.0 $ git push origin tag 2.0 Total 0 (delta 0), reused 0 (delta 0) To ../git_101_bare/ * [new tag] 2.0 - 2.0 Listing tags: $ git tag -l 1.0 2.0 Logging the whole thing: git reflog Reflog is a mechanism which Git tracks the updates to the tip of branches. Even though the changesets are not referenced by any branch or tag. Thus, you can go back to them. After rewriting history, the reflog contains information about the old state of branches. $ git reflog 18b2e67 HEAD@{0}: checkout: moving from developer to third 48f97a4 HEAD@{1}: checkout: moving from master to developer 8178777 HEAD@{2}: checkout: moving from third to master 18b2e67 HEAD@{3}: checkout: moving from master to third 8178777 HEAD@{4}: merge developer: Merge made by the 'recursive' strategy. 18b2e67 HEAD@{5}: merge third: Fast-forward 9e97315 HEAD@{6}: checkout: moving from developer to master 48f97a4 HEAD@{7}: commit: One more file on dev 9e97315 HEAD@{8}: checkout: moving from master to developer 9e97315 HEAD@{9}: checkout: moving from third to master 18b2e67 HEAD@{10}: commit: File on third branch 9e97315 HEAD@{11}: checkout: moving from master to third 9e97315 HEAD@{12}: merge developer: Fast-forward 40bcf0d HEAD@{13}: checkout: moving from developer to master 9e97315 HEAD@{14}: commit: Filed added on Dev branch 40bcf0d HEAD@{15}: checkout: moving from master to developer 40bcf0d HEAD@{16}: commit: newest_file.txt added 76a3398 HEAD@{17}: commit: Changed content new_file.txt 85c2310 HEAD@{18}: commit (amend): .gitignore added 44e0174 HEAD@{19}: commit: .gitignored added 13abdd5 HEAD@{20}: commit (initial): Initial commit To go back to an old state, use git reset --hard <commit hash Resolving conflicts In many cases, you might see conflicts using Git . It consists basically of the same part of a file is changed on commits in two different branches without being updated before (merging). For example, if you make a change on a particular line in a file, and your colleague working in a repository makes a change on the exact same line, a merge conflict occurs. To solve that, you need to merge the file checking which differences must be remained in the file. After resolving the conflicts, you can add the file to index back again. A conflict-marked area begins with , the conflict markers. The two conflicting blocks themselves are divided by a =======. They need to be removed from the file after you inspect the file. 99db324742823c55d975b605e1fc22f4253a9b7d On this post, there are the main commands that you will use. But there are many others that you can check it out on its official documentation git-scm.com Complementary readings Git Howto: Revert a Commit Already Pushed to a Remote Repository","tags":["git","scm","version","control"],"image":"http://i.imgur.com/KZeAkUA.png","title":"Git: Actual guide with actual examples","label":"lab"},{"path":"grsd","date":"2016-07-14T18:10:27.000Z","content":"gsrd downloads your public starred repos. Just in case you want to keep a backup of them from time to time. Configuration Getting your credential In order to keep your privacy, create your personal token on Github . You just need to select the option public_repo as shown below: Installation $ gem install gsrd Run Run the code passing your access token as argument $ gsrd \" put your forty character generated string here \" Requirement wget License The MIT License (MIT) Copyright (c) 2016 Leonardo Cardoso Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":["GitHub","ruby"],"image":"http://i.imgur.com/XWAYwCu.jpg","title":"GitHub Starred Repos Downloader","label":"lab"},{"path":"half-open-hashing","date":"2013-10-14T01:25:20.000Z","content":"Approach This approach is a mix of Open Hashing with Avl and Rehashing , but the threshold in this case is the height of AVL tree. Addionatlly, it uses only the quadratic probing. Resizing There is a difference in the operation of resizing. If a data cannot be inserted due to the tree size or there's not empty slot (or still if an element is repeated in the tree, since AVL is a search data structure, which is why it does not accept repeated elements), the resize operation is performed. If an element already exists in the tree, it tries to find an empty slot using quadratic probing. Load Factor and Balancing Factor The Hash Table Load Factor in Half Open Hashing is the max height among the trees of hash table nodes. The Hash Table Balancing Factor in Half Open Hashing is the sum of the heights of the trees of hash table nodes divided by number of the size times max height (load factor) . Code snippets Below you will see a half open hashing. public class AvlTreeForHalfOpenHashing { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public boolean insert(int key, int value) { TreeNode n = new TreeNode(key, value); return insertAvl(this.root, n); } /** Insert new node */ private boolean insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key = currentNode.key) { if (newNode.key != currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } if (newNode.key == currentNode.key) { System.out.print(\"\\nKey \" + newNode.key + \" already exists on this tree. \"); return false; } } } return true; } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class AvlNodeForHalfOpenHashing { private int key; private int value; private AvlTreeForHalfOpenHashing avlTree; public AvlNodeForHalfOpenHashing(int key, int value) { this.avlTree = new AvlTreeForHalfOpenHashing(); this.avlTree.insert(key, value); this.key = key; this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public AvlTreeForHalfOpenHashing getAvlTree() { return avlTree; } public void setAvlTree(AvlTreeForHalfOpenHashing avlTree) { this.avlTree = avlTree; } } public class HalfOpenHashing { private final static int TABLE_INITIAL_SIZE = 13; /** In this case, the threshold is a max size of the tree */ private static final int THRESHOLD = 2; private static AvlNodeForHalfOpenHashing[] table; public HalfOpenHashing() { table = new AvlNodeForHalfOpenHashing[TABLE_INITIAL_SIZE]; for (int i = 0; i treeNodes = oldTable[i].getAvlTree() .inOrder(); for (TreeNode treeNode : treeNodes) { put(treeNode.getKey(), treeNode.getValue()); } } } } /** * The Hash Table Load Factor in Half Open Hashing is the max height among * the trees of hash table nodes */ public double loadFactor() { int maxHeight = 0; for (int i = 0; i maxHeight) { maxHeight = height; } } return maxHeight; } /** * The Hash Table Balancing Factor in Half Open Hashing is the sum of the * heights of the trees of hash table nodes divided by number of the size * times max height(load factor). (h1+h2+...+hn)/(TABLE_INITIAL_SIZE * H) */ public double balancingFactor() { double maxHeight = 0; double heightsSum = 0; for (int i = 0; i maxHeight) { maxHeight = height; } } return (heightsSum / ((double) table.length * maxHeight)); } public AvlNodeForHalfOpenHashing[] getTable() { return table; } } Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 13 and the threshold = 3 will produce the following result: Position 0. 13 \\ 52 Position 1. 13 \\ 66 Position 2. 28 Position 3. 55 / \\ / \\ 42 68 / 29 Position 4. 13 Position 5. 31 Position 6. 6 Position 7. [ ] Position 8. [ ] Position 9. [ ] Position 10. 23 Position 11. 24 \\ 37 Position 12. [ ] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","tags":["hashing","hash","algorithms","Java"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Half Open Hashing","label":"lab"},{"path":"hash-table-and-hashing-algorithms","date":"2013-10-13T15:26:22.000Z","content":"Hash Table Hash table (also hash map) is a data structure used to implement an associative array, a structure that can map keys to values. Implementally talking, hash table is an array-based data structure, which uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found. It's designed to keep insertion, deletion search with O(1) complexity. Hash Function Hash Function is the main feature of hash table design. It should assign each possible key to a unique slot. Although this ideal situation is rarely achievable in practice. Additionally, to offset this rarity different keys that are assigned by the hash function to the same bucket, called hash collisions, will occur and must be accommodated in some way. But if the hash function cause too many collisions, the hash table overall performance will be badly affected. Hash Table and Load Factor The load factor of a hash table is the ratio between the number of stored items and the array size. With its different implementations, hash table can whether be of a constant size or being dynamically resized, when load factor exceeds some threshold. Collisions What happens, if hash function returns the same hash value for different keys? It yields an effect, called collision. Collisions are practically unavoidable. Due to collisions, keys are also stored in the table, so one can distinguish between key-value pairs having the same hash. There are various ways of collision resolution. Basically, there are three different strategies with several branches: Open Hashing (also Closed addressing or Separate Chaining): Each slot of the hash table contains a link to another data structure (i.e. linked list or AVL tree), which stores key-value pairs with the same hash. When collision occures, this data structure is searched for key-value pair, which matches the key. Closed Hashing (also Open addressing): Each slot actually contains a key-value pair. When collision occurs, open addressing algorithm calculates another location (i.e. next one) with a linear or quadratic probing to locate a free slot. Another approach in Closed Hashing, called Rehashing that can be with linear or quadratic probing, is about resizing the hash table if some threshold is exceeded. Half Open Hashing (Mix of Open Hashing with AVL and Rehashing). Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","tags":["hash","hashing","algorithms","Java"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Hash Table and Hashing Algorithms","label":"lab"},{"path":"heap-sort","date":"2015-01-12T01:56:26.000Z","content":"Heap Sort is a comparison-based algorithm and can be considered as an improvement of Selection Sort and like that Selection, it separates the input into to a sorted and an unsorted region, and at each interaction it shrinks the unsorted region by extracting the smallest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the minimum. Both algorithms along with 5 others can be found here . On this post, we use Heap Sort as a application of Priority Queues . That means that we have an unsorted Binary Heap and we use the Heap Sort to make it sorted. See its visualization: Source: Wikipedia Code snippets Below you will see heap sort which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } public class HeapSort { private BinaryHeap binaryHeap = new BinaryHeap(); private ArrayList priorityQueue = new ArrayList (); private Pair[] heapified; /** * Heap sort is simply to inheap the elements to priority queue, and outheap * elements */ public Pair[] sort(Pair[] set) { heapified = new Pair[set.length]; /** Build initial heap */ heapify(set); heapSort(); return heapified; } private void heapify(Pair[] set) { /** Heapifying */ for (int i = 0; i Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Before sorting After sorting Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","min","heap","sort","heapsort"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"Heap Sort","label":"lab"},{"path":"i18n-php-angularjs","date":"2015-08-13T20:56:05.000Z","content":"Basically, we use a cookie to set the current language, php classes to store the words for each language, and ajax calls to update the language. See how it works below... I18n.class.php This class is the base php class. It has all the base stuff like empty arrays and the base functions. The \"setUp()\" function, populates the main array \"var $i18n = [];\" with all the other ones in the class. The main function \"getLang($langRequests = [])\" will return the dictionary choosen by the user that was picked from the \"$i18n\" array. <?php class I18n { var $login = []; var $notFound = []; var $error = []; var $success = []; var $i18n = []; function setUp() { $this-i18n = [ \"login\" = $this-login, \"notFound\" = $this-notFound, \"error\" = $this-error, \"success\" = $this-success, ]; } function getLang($langRequests = []) { $this-setUp(); $result = []; foreach ($langRequests as $request) { $selection = $this-i18n[$request]; $result = array_merge($result, $selection); } return $result; } } ? ptBr.class.php This \"Language\" class extends the \"I18n\" class, with the custom messages in Portuguese. <?php include_once \"I18n.class.php\"; class Language extends I18n { function __construct() { $this-login = [ \"login\" = \"Fazer login\", // ... ]; $this-notFound = [ \"not_found_title\" = \"Página não encontrada\", // ... ]; $this-error = [ \"error_default_error\" = \"Algo inesperado ocorreu, tente novamente em instantes.\", // ... ]; $this-success = [ \"login_success\" = \"Login realizado com successo\", // ... ]; } } ? enUs.class.php This \"Language\" class extends the \"I18n\" class, with the custom messages in English. If you noticed, both \"ptBr.class.php\" and \"enUs.class.php\" files contain the same class called Language. This is so for keeping a generic way to get the dictionaries in the selected file. That class will be loaded in the next file \"lang.php\". <?php include_once \"I18n.class.php\"; class Language extends I18n { function __construct() { $this-login = [ \"login\" = \"Login\", ]; $this-notFound = [ \"not_found_title\" = \"Page not found\", ]; $this-error = [ \"error_default_error\" = \"Something unusual has happened, try again later.\", ]; $this-success = [ \"login_success\" = \"Successfully logged in\", ]; } } ? lang.php This file returns the dictionary on the file loaded by the cookie in JSON format. <?php $file = (isset($_COOKIE['i18n']) ? $_COOKIE['i18n'] : \"ptBr\") . \".class.php\"; $file = file_exists($file) ? $file : \"ptBr.class.php\"; include_once $file; $language = new Language(); echo json_encode($language-getLang($_POST[\"langRequests\"])); ? changeLanguage.php This file only sets the new language cookie. <?php $time = time() + (86400 * 30 * 365); // one year setcookie(\"i18n\", $_POST[\"lang\"], $time, \"/\"); ? app.js This file is the your Angular App file. var MyApp = angular.module('MyApp', []); lang.js This file contains a service that will check the JSON returned by the \"lang.php\" file and will change the {{(.*)}} key with its correspondent value. MyApp .service('langService', function() { var dictionary; var langService = {}; langService.i18n = function ($scope, $http, $langRequests) { $http.post('php/lang.php', { langRequests: $langRequests }).then(function (resp) { dictionary = resp.data; for (var k in dictionary){ if (dictionary.hasOwnProperty(k)) { $scope[k] = dictionary[k]; //console.log(k + \" - \" + dictionary[k]); } } }, function (err) { console.error('ERR', err); }) }; return langService; }); myController.js This file is your Angular Controller. You can do your stuff here, but the first action must be the language configurations. So you can say which arrays you want to be loaded in the current page. MyApp .controller('myController', ['$scope', '$http', 'langService', function($scope, $http, langService) { // select which messages group you want var $langRequests = [\"login\", \"notFound\", \"error\", \"success\"]; langService.i18n($scope, $http, $langRequests); $scope.languageSelect = function(lang) { $http.post('php/changeLanguage.php', { lang: lang }).then(function() { window.location = window.location; }) } } ]); Obs 1: The order of the files must be the following: <script src=\"https://dl.dropboxusercontent.com/s/js/angularjs/angular.min.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/app.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/lang.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/myController.js\"></script> Obs 2: The arrays you request in the myController.js variable \" var $langRequests = [];\" must be the same name as the i18n and its extended classes, like \"login\".","tags":["php","angularjs","i18n"],"image":"https://raw.githubusercontent.com/LeonardoCardoso/i18n-PHP-Angularjs/master/assets/php-angularjs-i18n.jpg","title":"An approach about i18n, PHP and AngularJS","label":"lab"},{"path":"k-numbers","date":"2015-01-12T14:55:04.000Z","content":"K-Numbers is a applied usage of Priority Queue . Its concept is about keep the smallest (or largest depending on the rule we want) k numbers on the top at each insertion into the heap. Insertion : given the set of numbers, we run the entire set and we inheap only the numbers less than (for the K-smallest) or greater than (for the K-largest) the contained ones already in the heap. Note that if the current interaction of the array is less than K, we simply add that element to the heap. The comparisons and necessary swaps are only performed when the array set is greater than K. Here, we use the algorithm to print our K-Numbers. Code snippets Below you will see a K-Numbers heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } /** The Smallest/largest k numbers (consider priorities) of a priority queue */ public class KNumbers { public static final int SMALLEST = 0, LARGEST = 1; private ArrayList kList = new ArrayList (); public ArrayList get(Pair[] set, int k, int type) { BinaryHeap binaryHeap = new BinaryHeap(type); int i = 0; /** Inheap the k first elements */ for (i = 0; i binaryHeap.top(kList).p) { kList.set(0, set[i]); binaryHeap.swapHeapUpDown(kList, binaryHeap.top(kList)); } } } return kList; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} and K = 3 will produce the following result: 3 Largest 3 Smallest Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","numbers"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"K-Numbers","label":"lab"},{"path":"leftist-tree","date":"2015-01-13T23:49:23.000Z","content":"Leftist Tree is a binary tree which has always more elements at left than right. Its structure is controlled by a value called NPL (Null Path Length). Leftist Tree is not a search structure, then it allows duplicate values and in contrast to a binary heap, a leftist tree attempts to be very unbalanced. NPL (AKA s-value or rank) is the distance of level (height) of a node to the nearest leaf. If a node has no child or only one child, its NPL = 0; if its two children, its NPL = 1; and so on. The following propositions define an Leftist Tree: npl (child left) = npl (child right). priority (node) = priority (node.left) = priority (node.right). This priority can be the node value. Insertion : When inserting a new node into a tree, the new node considered as a tree to be merged into the existing tree. Deletion : To delete a minimum item, we remove the root and the left and right subtrees are then merged. Insertions and deletions take O (log N) time. The main advantage of Leftist Trees are their ability to merge quickly, compared to binary heaps which take O (N). Code snippets Below you will see a Leftist Tree. public class LeftistTreeNode { public String value; public LeftistTreeNode left; public LeftistTreeNode right; public LeftistTreeNode parent; public LeftistTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } /** * Rules * 1. npl(left) = npl(right) * 2. prio(root) = prio(root.left) = prio(root.right) * Leftist tree is not a search structure, then it allows duplicate values */ public class LeftistTree { public LeftistTreeNode root; /** * Core Functions */ public void insert(String value) { LeftistTreeNode n = new LeftistTreeNode(value); insertLeftistTree(this.root, n); } /** * Insert new node */ private void insertLeftistTree(LeftistTreeNode currentNode, LeftistTreeNode newNode) { if (currentNode == null) { this.root = newNode; this.root.parent = null; } else { merge(currentNode, newNode); } } /** * Lazy merge: joins two left trees */ public void merge(LeftistTreeNode root, LeftistTreeNode newNode) { // Considering the tree.element with largest value on the top if (root.parent == null && root.value.compareTo(newNode.value) leftNpl || (rightNpl == leftNpl && leftValue.compareTo(rightValue) 0) { // invert here to change to small priority on top newRoot = toBeRemoved.left; newRoot.parent = null; merge(newRoot, toBeRemoved.right); this.root = newRoot; } else { newRoot = toBeRemoved.right; newRoot.parent = null; merge(newRoot, toBeRemoved.left); this.root = newRoot; } performSwap(this.root.right); System.out.println(\"\\nElement removed successfully.\"); } } } /** * Helper Functions */ public LeftistTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(LeftistTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Calculating the height of a node according to the root. */ public int heightRootToNode(LeftistTreeNode currentNode) { int height = 0; while (currentNode.parent != null) { height++; currentNode = currentNode.parent; } return height; } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(LeftistTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","tags":["java","leftist","tree"],"image":"http://i.imgur.com/1mMV9xR.jpg","title":"Leftist Tree","label":"lab"},{"path":"link-preview","date":"2015-10-23T03:09:40.000Z","content":"Hey, guys! This is the new version of Facebook Link Preview. It's built in AngularJS + Bootstrap. Lighter, faster, more beautiful and highly customizable. Let's go to the awesomeness! HTTP Server Apache (must support mod_php) How to add it to your project 1 • Stylesheets <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\" rel=\"stylesheet\" <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\" <link rel=\"stylesheet\" type=\"text/css\" href=\"src/link-preview/css/link-preview.css\" / 2 • Scripts <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\" type=\"text/javascript\"</script <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js\"</script <script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js\" type=\"text/javascript\"</script <script src=\"src/link-preview/js/link-preview.js\" type=\"text/javascript\"</script <!-- Include this script below if you want to retrieve the posts inserted to database -- <script src=\"src/link-preview/js/link-preview-database.js\" type=\"text/javascript\"</script 3 • Configuration Add the link preview module as a dependency to your application module: var app = angular.module('App', ['linkpreview']) Add the directive inside your controller html: <link-preview placeholder=\"What's in your mind?\" / Options att var default value possible values type type right right, left, bottom, top (text position) amount imageAmount -1 any integer btext buttonText Post any string bclass buttonClass primary default, primary, success, info, warning, danger, link cbtext cancelButtonText Cancel any string cbclass cancelButtonClass danger default, primary, success, info, warning, danger, link ltext loadingText Loading any string limage loadingImage empty.png any image url placeholder placeholder an empty string any string ttext thumbnailText Choose a thumbnail any string nttext noThumbnailText No thumbnail any string tpage thumbnailPagination %N of %N any string, %N is the number reference of pagination dtitle defaultTitle Enter a title any string ddescription defaultDescription Enter a description any string <link-preview type=\"\" ttext=\"\" tpage=\"\" placeholder=\"\" amount=\"\" limage=\"\" ltext=\"\" btext=\"\" bclass=\"\" ctext=\"\" cclass=\"\" dtitle=\"\" ddescription=\"\" / 4 • Database To custom your database configurations, you need to change the following values in Database.php $host = \"localhost\"; $user = \"\"; $password = \"\"; $database = \"linkpreview\"; Additionally, the way I used to retrieve the data was creating a controller link-preview-database.js which you can include the file somehow in your project or you can its content to yours. app.controller('MyControllerDatabase', ['$scope', '$http', function ($scope, $http) { $scope.databasePosts = []; $scope.retrieveFromDatabase = function () { // You must insert in your page a div with the posts retrieved from database. Just like the posts div // on template html files var url = 'src/link-preview/php/retrieve.php'; $http({ url: url, method: \"GET\", headers: {'Content-Type': 'application/x-www-form-urlencoded'} }).success(function (data, status, headers, config) { for (var i = 0; i Also, check the file database-template.php to see an example of how to display the data retrieved from database. Make sure your columns are the same as those ones in linkpreview.sql or customize them. Result Format { \"title\":\"title\", \"url\":\"original url\", \"pageUrl\":\"page url\", \"canonicalUrl\":\"canonical url\", \"description\":\"description\", \"images\": [\"array of images\"], \"image\": \"first image of images\", \"video\":\"true|false\", \"videoIframe\":\"video iframe, if it is a video\" } Important Make sure the library php5-curl is installed and enabled on the server, either locally or remotely. - Linux $ sudo apt-get install php5-curl $ sudo service apache2 restart - Mac (via macports) $ sudo port install php5-curl $ sudo apachectl restart","tags":["Facebook","Link Preview","PHP","jQuery"],"image":"https://raw.githubusercontent.com/LeonardoCardoso/Link-Preview/master/demo/img/simple.png","title":"Link Preview: An AngularJS + Boostrap multilayout link previewer\r\n","label":"lab"},{"path":"min-max-heap","date":"2015-01-09T01:39:43.000Z","content":"Like a binary heap, Mix-max heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right. Unlike a binary heap, the nodes do not follow min-heap or max-heap, but a double-ended approach. The elements at and even level in the tree is less than all of its children, and the elements at an odd level is greater than all of its children. Min-max heaps has the properties of O(log n) insertion and deletion, can be built in time O(n), just like binary heaps. They are often represented implicitly in an array. Code snippets Below you will see a min max heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } public class MinMaxHeap { /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** * Outheap the highest heaps.element with the minimum priority of priority queue, * then put its grandchild with the largest priority in its place and the * bottom in the grandchilds place */ public void outHeapMin(ArrayList priorityQueue) { if (size(priorityQueue) 3) { int childIndex = 3; Pair bottom = bottom(priorityQueue); Pair grandChild2 = null; Pair grandChild3 = null; Pair grandChild4 = null; if (size(priorityQueue) 4) { grandChild2 = priorityQueue.get(4); if (grandChild2.p 5) { grandChild3 = priorityQueue.get(5); if (grandChild3.p 6) { grandChild4 = priorityQueue.get(6); if (grandChild4.p priorityQueue) { if (size(priorityQueue) 7) { int maxIndex1 = 1; int maxIndex2 = 2; int changeIndex = maxIndex1; Pair max1 = priorityQueue.get(maxIndex1); Pair max2 = priorityQueue.get(maxIndex2); int childIndex = 7; int childIndexOffset = childIndex; if (max1.p max2.p) { childIndex = (2 * maxIndex1 + 1) + (2 * maxIndex1 + 1) + 1; } else { childIndex = (2 * maxIndex2 + 1) + (2 * maxIndex2 + 1) + 1; changeIndex = maxIndex2; } Pair bottom = bottom(priorityQueue); Pair grandChild2 = null; Pair grandChild3 = null; Pair grandChild4 = null; if (size(priorityQueue) childIndexOffset + 1) { grandChild2 = priorityQueue.get(childIndexOffset + 1); if (grandChild2.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 1; } if (size(priorityQueue) childIndexOffset + 2) { grandChild3 = priorityQueue.get(childIndexOffset + 2); if (grandChild3.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 2; } if (size(priorityQueue) childIndexOffset + 3) { grandChild4 = priorityQueue.get(childIndexOffset + 3); if (grandChild4.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 3; } priorityQueue.set(changeIndex, priorityQueue.get(childIndex)); priorityQueue.set(childIndex, bottom); priorityQueue.remove(priorityQueue.size() - 1); findChildren(priorityQueue, childIndex, true); } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; int level = levels(xPosition); /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root * * Even levels keep the min priorities * * Odd levels keep the max priorities */ while (xParentPosition != 0) { int xGrandParentPosition = xParentPosition / 2; if (level % 2 == 0) { if (xGrandParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (xGrandParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xGrandParentPosition - 1).p) { swap(priorityQueue, xPosition, xGrandParentPosition); } else if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the highest heaps.element with the maximum priority of priority queue */ public Pair topMax(ArrayList priorityQueue) { Pair x = priorityQueue.get(0); Pair left = x; Pair right = x; if (priorityQueue.size() 1) left = priorityQueue.get(1); if (priorityQueue.size() 2) right = priorityQueue.get(2); return (left.p right.p ? left : right); } /** * Return the number of levels of priority queue */ public int levels(int position) { return (int) (Math.log(position) / Math.log(2)); } /** * Return the number of elements of priority queue */ public int size(ArrayList priorityQueue) { return priorityQueue.size(); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Reorganize children of an heaps.element */ private void findChildren(ArrayList priorityQueue, int elementPosition, boolean greaterThan) { int childIndex = elementPosition; int childLeftIndex = 2 * childIndex + 1; int childRightIndex = 2 * childIndex + 2; Pair grandChildLeft = null; Pair grandChildRight = null; if (childLeftIndex grandChildLeft.p) swapHeapDownUp(priorityQueue, grandChildRight, childRightIndex); else swapHeapDownUp(priorityQueue, grandChildLeft, childLeftIndex); } } else { if (grandChildLeft != null) { if (grandChildRight != null && grandChildRight.p priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","min","max","heap"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"Min-Max Heap","label":"lab"},{"path":"movement","date":"2015-01-19T21:30:42.000Z","content":"A funny way to interact with the mouse. It is excellent for Team showcases on your website. You can use a set of images to change according to mouse position on the screen. This way it gives the impressions of movement. It will work with devices with a pointer (mouse) in the screen. Have fun! Just follow the following simple steps to add it to your project 1 • Scripts <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'</script <script src='js/movement.js' </script 2 • Configuration Just create your own img tag (or multiple img tags ) with width and height specified whether inline or in css and bind it to jQuery like this: <img id=\"IMG ID\" style=\"width: 200px; height: 200px;\" <script $(document).ready(function() { $('IMG ID').movement({ center: \"http://i.imgur.com/tkStHbe.jpg\", up: \"http://i.imgur.com/cQ1YagQ.jpg\", upRight: \"http://i.imgur.com/8yVBOAZ.jpg\", right: \"http://i.imgur.com/7FccqSR.jpg\", downRight: \"http://i.imgur.com/CnIHIPB.jpg\", down: \"http://i.imgur.com/HbuZjKB.jpg\", downLeft: \"http://i.imgur.com/ve2uhtb.jpg\", left: \"http://i.imgur.com/rcaqqog.jpg\", upLeft: \"http://i.imgur.com/pOsZXC7.jpg\" }); }); </script option default value possible values center img/center.jpg any string up img/up.jpg any string upRight img/upRight.jpg any string right img/right.jpg any string downRight img/downRight.jpg any string down img/down.jpg any string downLeft img/downLeft.jpg any string upLeft img/upLeft.jpg any string","tags":["javascript","movement"],"image":"http://i.imgur.com/YgCWvfU.gif","title":"Movement","label":"lab"},{"path":"open-hashing","date":"2013-10-13T16:26:22.000Z","content":"Collision resolution by Open Hashing, also know as closed addressing or separate chaining. This approach is that each slot of the array contains a link to a linked list containing key-value pairs with the same hash. All new key-value pairs are added always to the end of the list. The search algorithm crawls through the list to find matching key of the givem hash. Initially table slots contain nulls until the first item is added. The time for hash table operations is the time to find the slot/bucket, which is O(1), plus the time for the list operation. Deletion is the same idea of Search, but when it finds the key and this key has a child, the algorithm links the found key child to its parent, if it's not the first item of the list. In a good hash table, each slot has zero or one entries, but at most three, because the optimized search can be affected with more values than that. Therefore, structures that are efficient in time and space for these cases are preferred. Illustration Code snippets Below you will see an open hashing with list heads. It means, that hash table entries store the elements themselves and not a pointer to it. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class OpenHashing { private final static int TABLE_INITIAL_SIZE = 7; private Node[] table; public OpenHashing() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 7 will produce the following result: 0. [42]-[28] 1. [29] 2. [23]-[37] 3. [24]-[52]-[66]-[31] 4. [ ] 5. [68] 6. [13]-[13]-[6]-[55]-[13] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Secondary images http://www.algolist.net/Data_structures/Hash_table/Chaining","tags":["Java","algorithms","hash","hashing","Open Hashing"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Open Hashing","label":"lab"},{"path":"open-hashing-with-avl","date":"2013-10-13T17:23:15.000Z","content":"Approach This approach is similar to Open Hashing , but instead using a linked list to handle collision, it uses an AVL tree on each slot to decrease the vertical deep of the hash. Code snippets Below you will see an open hashing with avl tree. public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public void insert(int key, int value) { TreeNode n = new TreeNode(key, value); insertAvl(this.root, n); } /** Insert new node */ private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nKey \" + newNode.key + \" already exists. Ignoring...\"); } } } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } System.out.println(\"Left: \" + l + \" Key: \" + node.key + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class AvlNode { private int key; private int value; private AvlTree avlTree; public AvlNode(int key, int value) { this.avlTree = new AvlTree(); this.avlTree.insert(key, value); this.key = key; this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public AvlTree getAvlTree() { return avlTree; } public void setAvlTree(AvlTree avlTree) { this.avlTree = avlTree; } } public class OpenAvlHashing { private final static int TABLE_INITIAL_SIZE = 7; private AvlNode[] table; public OpenAvlHashing() { table = new AvlNode[TABLE_INITIAL_SIZE]; for (int i = 0; i maxHeight) { maxHeight = height; } } return maxHeight; } /** * The Hash Table Balancing Factor in Half Open Hashing is the sum of the * heights of the trees of hash table nodes divided by number of the size * times max height(load factor). (h1+h2+...+hn)/(TABLE_INITIAL_SIZE * H) */ public double balancingFactor() { double maxHeight = 0; double heightsSum = 0; for (int i = 0; i maxHeight) maxHeight = height; } return (heightsSum / ((double) TABLE_INITIAL_SIZE * maxHeight)); } } Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 7 will produce the following result: Position 0. 42 / 28 Position 1. 29 Position 2. 23 \\ 37 Position 3. 52 / \\ / \\ 24 66 \\ 31 Position 4. [ ] Position 5. 68 Position 6. 13 / \\ 6 55 Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","tags":["hashing","hash","algorithms","Java","avl","tree","Open Hashing"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Open Hashing with AVL","label":"lab"},{"path":"pix-color-analyzer","date":"2014-10-03T08:40:26.000Z","content":"Library with the aim to analyze the pixel colors of an ARGB image. The picture above will generate a palette below. How to use that? Simple user the jar file. java -jar pca.jar [filename] [amount] You also can suppress amount. This way, the full palette will be generated. Obs.: For images that have many colors it can take a while to generate the window with the colors. java -jar pca.jar [filename] Palette Here the most dominant colors are printed in descending order","tags":["image","java","pixel"],"image":"http://i.imgur.com/wvTK9KE.jpg","title":"Pix Color Analyzer","label":"lab"},{"path":"priority-queues","date":"2015-01-07T15:30:27.000Z","content":"A priority queue is an abstract data type which is like a regular queue or stack data structure where each element has a priority attached. In it, the FIFO (first-in-first-out) rule is not necessarily followed. An element with a higher priority is taken before an element with lower priority. If two elements have the same priority, they are taken according to their order in the queue. An element can be inserted into a priority queue at any time, but only the element with highest priority can be retrieved for operations. The Priority Queue concept can be implemented in many different ways in different data structures. The structures with the best efficiency of priority queues are the heaps. Here we are gonna show some of them... Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap Avl Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"Priority Queues","label":"lab"},{"path":"radix-heap","date":"2015-01-12T15:25:54.000Z","content":"Radix Heap is the process to organize a PQ reducing its medium complexity of heap operation at the maximum. In this case, the PQ is divided in ranked pieces. Insertion and Deletion are made according to the ranks, from the smallest to the largest or vice versa while the priority is being treated. To create the ranks, first the largest priority must be know and the ranks can be as follows: [2^1][2^2][2^3][...][2^k] K is the power when 2^k is the first number greater than the largest priority. Then priorities lower than or equals 2^1 will be allocated in the first priority queue. Priorities greater than 2^1 and lower than 2^2 will be allocated in the second priority queue. And so on... Code snippets Below you will see a radix heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } public class RadixHeap { private ArrayList [] radixSet; private final int[] POWERS_OF_TWO = { 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824 }; public void organize(Pair[] set) { BinaryHeap binaryHeap = new BinaryHeap(BinaryHeap.LOW); int largestPriority = getLargestPriority(set); int kPower = getKPower(largestPriority); /** Initiate the radixSet */ radixSet = new ArrayList[kPower]; for (int i = 0; i (); /** Distribute elements to the correct priority queue */ for (int i = 0; i [] getRadixSet() { return radixSet; } /** Calculate the k power */ private int getKPower(int priority) { int k = 0; if (priority POWERS_OF_TWO[POWERS_OF_TWO.length - 1]) { k = POWERS_OF_TWO.length + 1; } else { for (int i = 1; i POWERS_OF_TWO[i - 1] && priority largestPriority) largestPriority = set[i].p; } return largestPriority; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)}: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","tags":["priority","queue","java","radix","sort","radixsort"],"image":"http://i.imgur.com/8DJn3OA.jpg","title":"Radix Heap","label":"lab"},{"path":"rehashing","date":"2013-10-13T23:23:19.000Z","content":"Collision resolution by Rehashing. As explained on Closed Hashing section, the calculus to find an empty slot is calculated using linear or quadratic probing. But to grant that the key-pair value will be inserted, this approach uses a threshold. When this threshold is reached, the size of hash table is increased to the closest prime number of the double of its size. And all current key-pair values are arranged in the new size of the hash table before the new one is inserted. Rehashing has positive and negative points. One of positive is the load factor is always under the threshold, and performance is really good; and of negative is that hash table can have a lot of unused empty spaces, increasing memory cost. Removal operation Like Closed Hashing, instead of just erasing the key, the algorithm writes a special key-pair (-1, -1) value to the slot to flag that slot as DELETED. Now lookup algorithm will work properly. Insertion algorithm should reuse deleted slots, when possible. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class PrimeNumbers { public static int findClosestPrimeNumber(int number) { int previous = 0; int next = 0; for (int i = 0; i number) { int rangeDown = Math.abs(PRIME_NUMBERS[previous] - number); int rangeUp = Math.abs(PRIME_NUMBERS[next] - number); if (rangeDown number) { return PRIME_NUMBERS[previous]; } } else break; } return number; } /** Some prime numbers */ private static final int[] PRIME_NUMBERS = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209 }; } public class RehashingLinear { private final int TABLE_INITIAL_SIZE = 11; private float threshold = 0.70f; private int maxSize = (int) (TABLE_INITIAL_SIZE * threshold); private int size = 0; private Node[] table; public RehashingLinear() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = maxSize) { resize(); } } /** Get item */ public void get(int key) { /** Run along the array */ int runner = 0; int hash = (key % table.length); while (table[hash] != null && runner Code below implements quadratic probing. And also this implementation is protected against entering infinite loop. public class RehashingQuadratic { private final int TABLE_INITIAL_SIZE = 11; private float threshold = 0.70f; private int maxSize = (int) (TABLE_INITIAL_SIZE * threshold); private int size = 0; private Node[] table; public RehashingQuadratic() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = maxSize) { resize(); } } /** Get item */ public void get(int key) { /** Run along the array */ int runner = 0; int hash = (key % table.length); /** * Quadratic probing only grants an element insertion while runner is * under the half of the table size. */ int edge = (int) Math.ceil((double) table.length / 2); while (table[hash] != null && runner Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 11 and the threshold = 0.7 will produce the following result: Linear 0. [23] 1. [24] 2. [ ] 3. [ ] 4. [ ] 5. [28] 6. [6] 7. [52] 8. [29] 9. [55] 10. [31] 11. [ ] 12. [ ] 13. [13] 14. [13] 15. [37] 16. [13] 17. [ ] 18. [ ] 19. [42] 20. [66] 21. [ ] 22. [68] Quadratic 0. [23] 1. [24] 2. [ ] 3. [ ] 4. [ ] 5. [28] 6. [6] 7. [52] 8. [31] 9. [55] 10. [29] 11. [ ] 12. [ ] 13. [13] 14. [13] 15. [37] 16. [ ] 17. [13] 18. [ ] 19. [42] 20. [66] 21. [ ] 22. [68] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"image":"http://i.imgur.com/KcnUKwx.png","title":"Rehashing","label":"lab"},{"path":"rotate-and-scale-jquery","date":"2012-05-25T01:10:09.000Z","content":"If you liked Scale and Rotate , you will probably like this jQuery plugin too. It's the mix of both. It's the same simple and useful usage. Options option default value possible values function event click, mouseover event which the animation will start at action increase increase, decrease animation behavior howMany 20 any integer how many times the element will be increased or decreased initialSize element width any integer starting width finalSize element width any integer final width pixels 1 any integer how many pixels will be increased or decreased at once rotateAndScaleTime 0 any integer animation speed in milliseconds keepScaling no yes, no if keepScalling is equal to yes, the animation will stop at inicialSize + howMany ou inicialSize - howMany frequency one one, continuous if frequency is equal to continuous, the animation will keep being performed until there is a stop condition, if there's not it'll be performed forever plane both vertical, horizontal orientation of animation way right right, left animation way time 0 any integer performing time in milliseconds speed 1 any integer animation speed (how many pixels will be rotated at once) degrees any integer between 0 and 360 how many degrees to be rotated $('#rotateAndScale').rotateAndScale(); $('#foo').rotateAndScale({event: \"click\", action: 'decrease'}); $('#bar').rotateAndScale({event: \"mouseover\", howMany: '40', rotateAndScaleTime: 50}); $('#leo').rotateAndScale({event: \"click\", howMany: '10', frequency: 'continuous'}); $('#hrz').rotateAndScale({way: \"left\", frequency: 'continuous', plane: 'horizontal', rotateAndScaleTime: 25}); $('#vrt').rotateAndScale({frequency: 'continuous', plane: 'vertical', action: 'decrease'}); $('#clock').rotateAndScale({way: \"left\", frequency: 'continuous', rotateAndScaleTime: 1000, pixels: 3});","tags":["jQuery","Scale","Rotate"],"image":"http://i.imgur.com/chj33Yl.png","title":"Rotate and Scale: jQuery","label":"lab"},{"path":"rotate-jquery","date":"2012-03-19T03:47:13.000Z","content":"Just like Scale , this post introduces a simple and useful jQuery plugin made by me that rotates whatever elements you want. It changes the element style. Below you can see how many different ways you can use it and see its default and possible values that can be assumed. Have you ever seen the time by a Chrome clock?! : : Options option default value possible values function event click, mouseover event which the animation will start at way right right, left animation way time 0 any integer performing time in milliseconds speed 1 any integer animation speed (how many pixels will be rotated at once) degrees any integer between 0 and 360 how many degrees to be rotated clock no yes, no to assume the position of a clock hour no yes, no clock hours minute no yes, no clock minutes second no yes, no clock seconds $('#chrome').rotate(); $('#chromium').rotate({way: 'left', speed: 3}); $('#chrome1').rotate({way: 'left', event: 'mouseover'}); $('#chromium1').rotate({event: \"click\", way: 'right', speed: 15}); $('#chrome2').rotate({time: 1000, speed: 6}); $('#chromium2').rotate({event: \"mouseover\", degrees: 180, time: 10, speed: 5}); $('#rotate').rotate({event: \"click\", degrees: 90});","tags":["jQuery","Rotate"],"image":"http://i.imgur.com/LMmnB15.png","title":"Rotate: jQuery","label":"lab"},{"path":"scale-jquery","date":"2012-03-14T02:56:31.000Z","content":"This post introduces a simple and useful jQuery plugin made by me that scales whatever elements you want. It changes the element style. Below you can see how many different ways you can use it and see its default and possible values that can be assumed. Don't forget to declare element width and height in css ou in style (this is fundamental) . Options option default value possible values function event click, mouseover event which the animation will start at action increase increase, decrease animation behavior howMany 20 any integer how many times the element will be increased or decreased initialSize element width any integer starting width finalSize element width any integer final width pixels 1 any integer how many pixels will be increased or decreased at once scaleTime 0 any integer animation speed in milliseconds keepScaling no yes, no if keepScalling is equal to yes, the animation will stop at inicialSize + howMany ou inicialSize - howMany frequency one one, continuous if frequency is equal to continuous, the animation will keep being performed until there is a stop condition, if there's not it'll be performed forever plane both vertical, horizontal orientation of animation $('#scale').scale(); $('#chrome').scale({event: \"click\"}); $('#foo').scale({event: \"click\", action: 'decrease'}); $('#bar').scale({event: \"mouseover\", howMany: '40', scaleTime: 50}); $('#leo').scale({event: \"click\", howMany: '10', frequency: 'continuous'}); $('#hrz').scale({frequency: 'continuous', plane: 'horizontal', scaleTime: 25}); $('#vrt').scale({action: 'decrease', frequency: 'continuous', plane: 'vertical'}); $('#clock').scale({frequency: 'continuous', scaleTime: 1000, pixels: 3});","tags":["jQuery","Scale"],"image":"http://i.imgur.com/qdEbUgw.png","title":"Scale: jQuery","label":"lab"},{"path":"single-compilation-unit-cc","date":"2012-03-13T04:33:16.000Z","content":"Single Compilation Unit , also known as Separate Compilation , is a technique of the programming languages C/C++ that allows to reduce the compilation time and aims to help the compiler to perform optimization of the program, even when the compiler itself doesn't support the optimization of the entire program or precompiled headers. Generally, a C/C++ development environment assumes that .c/.cpp source files are preprocessed (the moment which the compiler expands the source file and includes all the headers described in the file, in other words, creating of translation units) and translated separately by the compiler, generating object code files (.o or .obj), which can then be linked together to create a executable library or file (.exe on Windows , for example). This process leads to several passages that are being performed in header files (.h) common, and with C++, multiple template instantiations of the same template in different translation units, thus having a replication code. The Separate Compilation technique uses preprocessor directives to \"stick\" different translation units at compile time, not at link time. Thus, reducing the overall compile time, but increasing the time needed to build after making small changes in any source file included in a single compilation unit. Therefore, the less the source files need to be modified best performance of this technique. CS also allows an optimizer to draw inner relationships between the functions, thus allowing optimizations such as creating inline functions (the copy function they are called in some other block of the program to this block where they are called). It also helps to avoid the implicit code bloat due to exceptions, side effects and register allocation, which are generally neglected by the classical scheme of using separate modules and not always achieved by the use of precompiled headers. Below is an example of separate compilation in C++, but in download files there's an example in C too: 1º - You must have a header file (.h) and insert in it only class and functions declarations, the scope will be defined in its .cpp correspondent file. The directives #ifndef #define #endif guarantee that if the preprocessor macro SEPARATECOMPILATION_H is already defined, the block inside its correspondent #ifndef will be ignored in the rest of the code, preventing this block to be processed more than once. #ifndef SEPARATECOMPILATION_H #define SEPARATECOMPILATION_H class fibonacci{ public: long long int numberCalculus(int); ~fibonacci(){}; }; #endif 2º - In the correspondent .cpp file to the .h file the scope of the class functions is defined, in this case. #include \"separateCompilation.h\" long long int fibonacci::numberCalculus(int number){ long long int temporary; int i; if(number == 0) temporary = 0; else if(number == 1 || number == 2) temporary = 1; else{ long long int before = 1, beforeBefore = 1; for(i = 2; i < number; i++){ temporary = beforeBefore + before; beforeBefore = before; before = temporary; } } return temporary; } 3º - In the end, you include the header file in the file that contains the main function. #include <iostream> #include \"separateCompilation.h\" using namespace std; int main(){ int userNumber; fibonacci fib; long long int result; cout << \"\\nEnter a number to calculate its Fibonacci number: \"; cin >> userNumber; result = fib.numberCalculus(userNumber); cout << \"\\n\"; if(result == -1){ cout << \"Invalid Number\"; } else if(result < -1){ cout << \"Result overflows long long int: \" << result; } else{ cout << \"Result is \" << result; } cout << \"\\n\\n\"; return 0; } Now, just compile all files .cpp and run the program. On Linux and Mac, you can use the g++ compiler to compile all .cpp files as follows: g++ on bash Now, the header file separateCompilation.h is compiled only once, and the function fibonacci::numberCalculus(int number) can be inlined directly in its class, despite being in another file.","tags":["C/C++","Programming"],"image":"http://i.imgur.com/Zkr1fX1.png","title":"Single Compilation Unit: C/C++","label":"lab"},{"path":"splay-tree","date":"2015-01-14T03:13:06.000Z","content":"Splay Tree is a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again, so they are splayed to the top. It performs basic operations such as insertion, search and removal in O(log n) amortised time. The elements are organised topologically to favour one access condition to the information or even to reduce the process complexity. Insertion is performed like a normal binary search, then the new node is splayed to the top. Deletion is also like a binary search tree with a slight difference: if the node has two children, swap its value with that of either the rightmost node of its left subtree or the leftmost node of its right subtree. Then remove that node. In this way, deletion is reduced to the problem of removing a node with 0 or 1 children. Differently of a binary search tree, in a splay tree after deletion, we splay the parent of the removed node to the top of the tree. Search it is a binary search as well, but after the access, we splay the element to the top to be more fast accessible next time. Rotations in Splay Tree are six: zig and zag : they are single right rotation and single left rotation respectively. The target element is lifted up by one level. zig-zag and zag-zig : double right rotation and double left rotation, like Avl double rotations . The target element is lifted up by two levels. zig-zig and zag-zag : they are also double rotations but instead alternating the directions of each rotations in it, the perform two rotations to right (zig-zig) and to rotations to left (zag-zag). And also the target element is lifted up by two levels Code snippets Below you will see a Splay Tree. public class SplayTreeNode { public String value; public SplayTreeNode left; public SplayTreeNode right; public SplayTreeNode parent; public SplayTreeNode(SplayTreeNode splayTreeNode) { if (splayTreeNode != null) { this.value = splayTreeNode.value; this.left = splayTreeNode.left; this.right = splayTreeNode.right; this.parent = splayTreeNode.parent; } } public boolean isNull() { return (this.value == null && this.left == null && this.right == null && this.parent == null); } public SplayTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class SplayTree { public SplayTreeNode root; /** * Core Functions */ public void insert(String value) { SplayTreeNode n = new SplayTreeNode(value); insertSplayTree(this.root, n); } /** * Insert new node */ private void insertSplayTree(SplayTreeNode currentNode, SplayTreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.value.compareTo(currentNode.value) 0) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; } else { insertSplayTree(currentNode.right, newNode); } } else { System.out.println(\"\\nValue \" + newNode.value + \" already exists. Ignoring...\"); } } } /** * Finds a node */ public SplayTreeNode find(String value) { SplayTreeNode result = find(this.root, value); if (result != null) { while (result.parent != null) { if (result.parent.parent == null) { // single rotations if (result.parent.left != null && result.parent.left.equals(result)) { // zig rotation result = zig(result); } else if (result.parent.right != null && result.parent.right.equals(result)) { // zag rotation result = zag(result); } } else { // double rotations if (result.parent.parent.left != null && result.parent.parent.left.left != null && result.parent.parent.left.left.equals(result)) { // zig-zig rotation result = zigZig(result); } else if (result.parent.parent.left != null && result.parent.parent.left.right != null && result.parent.parent.left.right.equals(result)) { // zag-zig rotation result = zagZig(result); } else if (result.parent.parent.right != null && result.parent.parent.right.left != null && result.parent.parent.right.left.equals(result)) { // zig-zag rotation result = zigZag(result); } else if (result.parent.parent.right != null && result.parent.parent.right.right != null && result.parent.parent.right.right.equals(result)) { // zag-zag rotation result = zagZag(result); } } } } if (result != null) { this.root = result; } return result; } /** * Finds a node */ public SplayTreeNode find(SplayTreeNode currentNode, String value) { if (value.equals(currentNode.value)) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (value.equals(currentNode.value)) return currentNode; else if (value.compareTo(currentNode.value) 0) return find(currentNode.right, value); else if (currentNode.left != null) return find(currentNode.left, value); else return null; } else { return null; } } /** * Rotation left to right */ private SplayTreeNode zig(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node); SplayTreeNode a = new SplayTreeNode(node.left); SplayTreeNode b = new SplayTreeNode(node.right); if (a.isNull()) a.parent = k1; if (b.isNull()) b.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node.parent); SplayTreeNode k2Parent = k2.parent; SplayTreeNode c = new SplayTreeNode(node.parent.right); if (c.isNull()) c.parent = k2; k2.left = b; k1.right = k2; b.parent = k2; k2.parent = k1; node = k1; node.parent = k2Parent; if (node.parent != null) { node.parent.left = node; } return node; } /** * Rotation right to left */ private SplayTreeNode zag(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node.parent); SplayTreeNode k1Parent = k1.parent; SplayTreeNode a = new SplayTreeNode(node.parent.left); if (a.isNull()) a.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node); SplayTreeNode b = new SplayTreeNode(node.left); SplayTreeNode c = new SplayTreeNode(node.right); if (b.isNull()) b.parent = k2; if (c.isNull()) c.parent = k2; k1.right = b; k2.left = k1; b.parent = k1; k1.parent = k2; node = k2; node.parent = k1Parent; if (node.parent != null) { node.parent.right = node; } return node; } /** * Double rotation left to right */ private SplayTreeNode zigZag(SplayTreeNode node) { return null; } /** * Double rotation right to left */ private SplayTreeNode zagZig(SplayTreeNode node) { return null; } /** * Double rotation left to left */ private SplayTreeNode zigZig(SplayTreeNode node) { return null; } /** * Double rotation right to right */ private SplayTreeNode zagZag(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node.parent.parent); SplayTreeNode k1Parent = k1.parent; SplayTreeNode a = new SplayTreeNode(node.parent.parent.left); if (a.isNull()) a.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node.parent); SplayTreeNode b = new SplayTreeNode(node.parent.left); if (b.isNull()) b.parent = k2; SplayTreeNode k3 = new SplayTreeNode(node); SplayTreeNode c = new SplayTreeNode(node.left); SplayTreeNode d = new SplayTreeNode(node.right); if (c.isNull()) c.parent = k3; if (d.isNull()) d.parent = k3; k1.left = a; k1.right = b; k2.left = k1; k2.right = c; k3.left = k2; k3.right = d; k3.parent = k1Parent; k1.parent = k2; k2.parent = k3; b.parent = k1; c.parent = k2; node = k3; if (node.parent != null) { node.parent.right = node; } return node; } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove() { removeSplayTree(this.root); } /** * Removes the node from the top.. */ private void removeSplayTree(SplayTreeNode startingNode) { } /** * Helper Functions */ public SplayTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(SplayTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(SplayTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: After searching 17 After searching 52 Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","tags":["java","splay","tree"],"image":"http://i.imgur.com/1mMV9xR.jpg","title":"Splay Tree","label":"lab"},{"path":"trees","date":"2015-01-13T22:27:37.000Z","content":"Tree is a very commonly used abstract data type (ADT) and one of the most powerful of the advanced data structures. A tree structure is basically with a root value (initial node) and subtrees of children, represented as a set of linked nodes. To understand the Tree Concept, some definitions must be remembered: Let's consider this image: Root is called the node without parent, the initial node. In our example this is node \"04\". Leaf is a node without children. In our example \"01\", \"03\" and \"06\". Internal nodes are the nodes, which are not leaf or root. \"02\" and \"05\". Depth of a node is the length of the path from the root to certain node. In our example \"04\" has depth zero because it's the root, \"05\" has depth one and \"03\" has depth two. Height of tree is the maximum depth of all its nodes. In our example the tree height is 2. A Tree can be defined recursively as a collection of nodes, starting at a root node, where each node is a data structure consisting of a value, together with a list of references to descendant nodes, the \"children\", with the constraints that no reference is duplicated, and none points to the root. The following statements are true for trees: Each node can have 0 or more direct descendants (children). Each node has at most one parent, except the root. All nodes are reachable from the root. Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","tags":["java","tree"],"image":"http://i.imgur.com/1mMV9xR.jpg","title":"Trees","label":"lab"}]