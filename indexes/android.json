[{"title":"Android: Custom Font without Memory Leak","image":"http://i.imgur.com/ggJmoAA.png","tags":["Android","Memory Leak","Custom"],"content":"If you want to use custom fonts in your Android app, you have to take note of an issue which might give you a headache: the memory. In this tutorial, you will see two ways to use custom fonts without memory leak, even if you use in a ListView. Well, these two ways are: XML natively and Java programmatically. Before showing these ways, let's see how avoid the memory leak. You create a SingleTon class to host the font file *.ttf you put in assets folder. In this case, open_sans.ttf file. So, there will be one only instance for the custom class. public class OpenSans { private static OpenSans instance; private static Typeface typeface; public static OpenSans getInstance(Context context) { synchronized (OpenSans.class) { if (instance == null) { instance = new OpenSans(); typeface = Typeface.createFromAsset(context.getResources().getAssets(), \"open_sans.ttf\"); } return instance; } } public Typeface getTypeFace() { return typeface; } } Now the two ways... 1. Natively You need to create a classe extending from the view you want to custom the typeface. I used a TextView. public class NativelyCustomTextView extends TextView { public NativelyCustomTextView(Context context) { super(context); setTypeface(OpenSans.getInstance(context).getTypeFace()); } public NativelyCustomTextView(Context context, AttributeSet attrs) { super(context, attrs); setTypeface(OpenSans.getInstance(context).getTypeFace()); } public NativelyCustomTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); setTypeface(OpenSans.getInstance(context).getTypeFace()); } } E and use XML as follows. // <com.leocardz.views.NativelyCustomTextView android:id=\"@+id/natively_text_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_margin=\"20dp\" android:text=\"@string/natively\" android:textSize=\"30sp\" /> 2. Programmatically Just find the view by id and set the new typeface. TextView programmaticallyTextView = (TextView) findViewById(R.id.programmatically_text_view); programmaticallyTextView.setTypeface(Gothic.getInstance(this) .getTypeFace()); That's it!","date":"2013-04-12T03:07:14.000Z","path":"android-custom-font-without-memory-leak"},{"title":"Android Link Preview","image":"http://i.imgur.com/HM8SmKK.png","tags":["link","preview","google","play"],"content":"This a version for Android of my web Link Preview . How to use with Gradle Simply add the repository to your build.gradle file: repositories { jcenter() maven { url 'https://github.com/leonardocardoso/mvn-repo/raw/master/maven-deploy' } } And you can use the artifacts like this: dependencies { compile 'com.leocardz:link-preview:1.1@aar' // ... } Like the php version, it makes a preview from an url, grabbing all the information such as title, relevant texts and images. It works even with shortened urls, image urls, etc... Watch a video of its work!","date":"2013-07-30T13:07:28.000Z","path":"android-link-preview"},{"title":"Animated Expanding ListView","image":"http://i.imgur.com/xImmSY6.png","tags":["listview","accordion"],"content":"Animated Expanding ListView provides a fancy animation on expanding or collapsing the content of a list view item. It works in all version of Android and it's very easy to adapt to your project. How to use with Gradle Simply add the repository to your build.gradle file: repositories { jcenter() maven { url 'https://github.com/leonardocardoso/mvn-repo/raw/master/maven-deploy' } } And you can use the artifacts like this: dependencies { compile 'com.leocardz:aelv:1.1@aar' // ... } Important Your list adapter must extend ArrayAdapter<? whatever ?> Your listview item must extend from AelvListItem Right after you create your listview item, you need to call yourItem.setUp(int collapsedHeight, int currentHeight, int expandedHeight, boolean isOpen); to setup the dimensions. Your listview item view holder must extend from AelvListViewHolder Right after you instantiate your view holder you need to call yourHolder.setViewWrap(viewWrap) ; and tell adapter that you are updating the item size calling holder.getViewWrap().setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT, listItem.getCurrentHeight())); . Right before you return the view on your custom adapter, you must call yourItem.setHolder(yourHolder) ; You need to instantiate Aelv aelv = new Aelv(isAccordion, animationDuration, yourListItems, yourListView, yourAdapter); right after you setup your listview. Last thing: your must implement listview.setOnItemClickListener(); and insert this aelv.toggle(view, position); inside the listener and voil√†! Just check the app example to see it clearly. Basically, you have to create a custom TranslateAnimation and a Custom List Adapter and, while it's animating, you have to update the current height of listview item and notify the adapter about this change. Something like that: public class ListItem extends AelvListItem { private String text; private int drawable; public ListItem(String text) { super(); this.text = text; this.drawable = R.drawable.down; } public String getText() { return text; } public void setText(String text) { this.text = text; } public int getDrawable() { return drawable; } public void setDrawable(int drawable) { this.drawable = drawable; } } // This allows Android OS to reuse your item in the list public class ListViewHolder extends AelvListViewHolder { private TextView textView; public ListViewHolder(TextView textView) { super(); this.textView = textView; } public TextView getTextView() { return textView; } public void setTextView(TextView textView) { this.textView = textView; } } public class ListAdapter extends ArrayAdapter { private ArrayList listItems; private Context context; public ListAdapter(Context context, int textViewResourceId, ArrayList listItems) { super(context, textViewResourceId, listItems); this.listItems = listItems; this.context = context; } @Override @SuppressWarnings(\"deprecation\") public View getView(int position, View convertView, ViewGroup parent) { ListViewHolder holder = null; ListItem listItem = listItems.get(position); if (convertView == null) { LayoutInflater vi = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); convertView = vi.inflate(R.layout.list_item, null); LinearLayout textViewWrap = (LinearLayout) convertView.findViewById(R.id.text_wrap); TextView text = (TextView) convertView.findViewById(R.id.text); holder = new ListViewHolder(text); // setViewWrap IS REQUIRED holder.setViewWrap(textViewWrap); } else { holder = (ListViewHolder) convertView.getTag(); } // THIS IS REQUIRED holder.getViewWrap().setLayoutParams(new AbsListView.LayoutParams(LayoutParams.MATCH_PARENT, listItem.getCurrentHeight())); holder.getTextView().setText(listItem.getText()); holder.getTextView().setCompoundDrawablesWithIntrinsicBounds(listItem.getDrawable(), 0, 0, 0); convertView.setTag(holder); // setHolder IS REQUIRED listItem.setHolder(holder); return convertView; } } public class MainActivity extends Activity { private ArrayList listItems; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView listView = (ListView) findViewById(R.id.list); listItems = new ArrayList (); mockItems(); ListAdapter adapter = new ListAdapter(this, R.layout.list_item, listItems); listView.setAdapter(adapter); // Setup // Aelv aelv = new Aelv(true, 200, listItems, listView, adapter); final Aelv aelv = new Aelv(true, 200, listItems, listView, adapter, new AelvCustomAction() { @Override public void onEndAnimation(int position) { listItems.get(position).setDrawable(listItems.get(position).isOpen() ? R.drawable.up : R.drawable.down); } }); listView.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView parent, View view, int position, long id) { aelv.toggle(view, position); } }); } private void mockItems() { final int COLLAPSED_HEIGHT_1 = 150, COLLAPSED_HEIGHT_2 = 200, COLLAPSED_HEIGHT_3 = 250; final int EXPANDED_HEIGHT_1 = 250, EXPANDED_HEIGHT_2 = 300, EXPANDED_HEIGHT_3 = 350, EXPANDED_HEIGHT_4 = 400; ListItem listItem = new ListItem(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"); // setUp IS REQUIRED listItem.setUp(COLLAPSED_HEIGHT_1, EXPANDED_HEIGHT_1, false); listItems.add(listItem); listItem = new ListItem(\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"); // setUp IS REQUIRED listItem.setUp(COLLAPSED_HEIGHT_2, EXPANDED_HEIGHT_2, false); listItems.add(listItem); // ... } } <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/text_wrap\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" > <TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"18sp\" /> </LinearLayout>","date":"2014-03-04T02:33:26.000Z","path":"animated-expanding-listview"},{"title":"Audio Preview","image":"http://i.imgur.com/uhKipcN.jpg","tags":["audio","preview"],"content":"A simple Android app to stream an audio by url for pre(view|listen)ing it. If you want to stream audio from a URL or URI (the path of the file inside your device), you will need a few steps shown in code below. You must pay attention when using MediaPlayer.release() and MediaPlayer.reset() methods, because they can lead your app to crash. The code below prevents that. public class MainActivity extends ActionBarActivity { private final String URL = \"https://dl.dropbox.com/s/hgcgq510urmgmed/01%20Main%20Title.mp3\"; private MediaPlayer mediaPlayer; private boolean isPlaying; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setUpMediaPlayer(); streamSong(URL); } private void setUpMediaPlayer() { if (mediaPlayer == null) { mediaPlayer = new MediaPlayer(); mediaPlayer.setOnBufferingUpdateListener(bufferingUpdateListener); mediaPlayer.setOnCompletionListener(completionListener); mediaPlayer.setOnErrorListener(errorListener); } } private void streamSong(String url) { if (mediaPlayer != null) { try { mediaPlayer.setDataSource(url); mediaPlayer.setOnPreparedListener(preparedListener); mediaPlayer.prepareAsync(); } catch (Exception e) { e.printStackTrace(); } } } private MediaPlayer.OnPreparedListener preparedListener = new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { if (mediaPlayer != null) { isPlaying = true; mediaPlayer.start(); } } }; private MediaPlayer.OnCompletionListener completionListener = new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { // End of audio isPlaying = false; } }; private MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i2) { // Error: We could stream song preview\" releaseMediaPlayer(); return false; } }; private MediaPlayer.OnBufferingUpdateListener bufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() { @Override public void onBufferingUpdate(MediaPlayer mediaPlayer, int i) { // Buffer started to play } }; private void releaseMediaPlayer() { if (mediaPlayer != null) { try { if (isPlaying) { mediaPlayer.stop(); isPlaying = false; } mediaPlayer.reset(); } catch (Exception e) { e.printStackTrace(); } } } @Override protected void onStop() { releaseMediaPlayer(); super.onStop(); } } Additionally, you will need these permissions to your manifest file: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission android:name=\"android.permission.INTERNET\" /> That's it!","date":"2014-05-28T11:37:23.000Z","path":"audio-preview"},{"title":"Audio Recorder","image":"http://i.imgur.com/d8OUqBq.jpg","tags":["audio","record"],"content":"A simple Android app to record an audio. I could reach a high quality recording by combining MPEG_4 format with AAC_ELD enconding. The AAC_ELD is available only from Jelly Bean (SDK 16) and setting encoding bit rate to 96000, buy If you want to use this code below version 16. As Audio Preview , you must pay attention when using MediaPlayer.release(), MediaRecorder.release() and MediaPlayer.reset() methods, because they can lead your app to crash. The code below prevents that. public class MainActivity extends ActionBarActivity { private static final String LOG_TAG = \"AudioRecord\"; private static String root = null; private static String audioPlayerName = null; private static Long millis; private Button recordButton = null; private Button playButton = null; private MediaRecorder recorder = null; private MediaPlayer mediaPlayer = null; private boolean isPlaying = false; private boolean isRecording = false; public MainActivity() { createDirectoriesIfNeeded(); millis = Calendar.getInstance().getTimeInMillis(); audioPlayerName = root + \"/\" + millis + \"audio.mp4\"; } private void createDirectoriesIfNeeded() { root = Environment.getExternalStorageDirectory().getAbsolutePath(); File folder = new File(root, \"AudioRecord\"); if (!folder.exists()) { folder.mkdir(); } File audioFolder = new File(folder.getAbsolutePath(), \"Audio\"); if (!audioFolder.exists()) { audioFolder.mkdir(); } root = audioFolder.getAbsolutePath(); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setUpIds(); setUpListeners(); } private void setUpIds() { recordButton = (Button) findViewById(R.id.record_button); playButton = (Button) findViewById(R.id.play_button); } private void setUpListeners() { recordButton.setOnClickListener(recordClickListener); playButton.setOnClickListener(playClickListener); } private View.OnClickListener recordClickListener = new View.OnClickListener() { public void onClick(View v) { isRecording = !isRecording; onRecord(isRecording); recordButton.setText(isRecording ? R.string.stop_recording : R.string.start_recording); playButton.setEnabled(!isRecording); } }; private View.OnClickListener playClickListener = new View.OnClickListener() { public void onClick(View v) { isPlaying = !isPlaying; onPlay(isPlaying); playButton.setText(isPlaying ? R.string.stop_playing : R.string.start_playing); recordButton.setEnabled(!isPlaying); } }; private void onRecord(boolean start) { if (start) { startRecording(); } else { stopRecording(); } } private void onPlay(boolean start) { if (start) { startPlaying(); } else { stopPlaying(); } } private void startPlaying() { mediaPlayer = new MediaPlayer(); try { mediaPlayer.setDataSource(audioPlayerName); mediaPlayer.setOnCompletionListener(completionListener); mediaPlayer.prepare(); mediaPlayer.start(); } catch (IOException e) { e.printStackTrace(); } } private MediaPlayer.OnCompletionListener completionListener = new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { stopPlaying(); } }; private void startRecording() { recorder = new MediaRecorder(); recorder.setAudioSource(MediaRecorder.AudioSource.MIC); // ACC_ELD is supported only from SDK 16+. // You can use other encoders for lower vesions. recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC_ELD); recorder.setAudioSamplingRate(44100); recorder.setAudioEncodingBitRate(96000); recorder.setOutputFile(audioPlayerName); try { recorder.prepare(); recorder.start(); } catch (IOException e) { e.printStackTrace(); } } private void stopRecording() { if (recorder != null) { recorder.release(); completionRecording(); } } private void stopPlaying() { if (mediaPlayer != null) { mediaPlayer.reset(); completionPlaying(); } } private void reset() { isRecording = false; isPlaying = false; } private void completionRecording() { reset(); recordButton.setText(R.string.start_recording); playButton.setText(R.string.start_playing); playButton.setEnabled(true); } private void completionPlaying() { reset(); playButton.setText(R.string.start_playing); recordButton.setEnabled(true); } @Override public void onPause() { super.onPause(); stopRecording(); stopPlaying(); } @Override public void onStop() { super.onStop(); stopRecording(); stopPlaying(); } } //R.layout.activity_main <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.leocardz.android.audio.recorder.MainActivity\"> <Button android:id=\"@+id/record_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/start_recording\" /> <Button android:id=\"@+id/play_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:enabled=\"false\" android:text=\"@string/start_playing\" /> </LinearLayout> Additionally, you will need these permissions to your manifest file: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> That's it!","date":"2014-05-28T12:16:52.000Z","path":"audio-recorder"},{"title":"Font-Awesomed Android","image":"http://i.imgur.com/S52SoL4.png","tags":["custom","font-awesome","fontawesome"],"content":"Using Font Awesome in any project allows you to make it beautiful and save your time that you would spend creating icons. What if it could be on Android?! How awesome would it be?! Fortunately, it is totally possible! You already know how to use custom fonts learned HERE: Custom Font without Memory Leak , then you need only to make few changes as follows: Add fontawesome.ttf on assets folder; Create FontAwesome class that makes reference to the file on assets folder; Create FontAwesomeTextView that uses FontAwesome as typeface; Create a set of strings referencing each Font Awesome icon; This would be the result!","date":"2014-05-10T09:15:06.000Z","path":"font-awesomed-android"},{"title":"Multiple Layout ListView","image":"http://i.imgur.com/iX1w41f.png","tags":["custom","adapter","layout"],"content":"This tutorial is about how to use multiple layouts in listview. Basically, you have to follow these steps: Create the custom layous; Create a custom adapter; Override getViewTypeCount() method in your custom adapter with the amount of layouts you're gonna use in your listview; Override getItemViewType(int position) method also in your custom adapter to return the current item's view type; Additionally, it's essential to use a view holder to avoid memory leaks. Take a look in the code below. First, we create custom layouts. In this case, four types. // even <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff500000\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"match_parent\" android:layout_gravity=\"center\" android:textSize=\"24sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // odd <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff001f50\" android:gravity=\"right\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"28sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // white <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ffffffff\" android:gravity=\"right\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/black\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"28sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> // black <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#ff000000\" android:layout_height=\"match_parent\"> <TextView android:id=\"@+id/text\" android:textColor=\"@android:color/white\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center\" android:textSize=\"33sp\" android:layout_height=\"wrap_content\" /> </LinearLayout> Then, we create the listview item. In our case, with a string and a type. public class ListViewItem { private String text; private int type; public ListViewItem(String text, int type) { this.text = text; this.type = type; } public String getText() { return text; } public void setText(String text) { this.text = text; } public int getType() { return type; } public void setType(int type) { this.type = type; } } After that, we create a view holder. It's strongly recommended because Android OS keeps the layout reference to reuse your item when it disappears and appears back on the screen. If you don't use this approach, every single time that your item appears on the screen Android OS will create a new one and causing your app to leak memory. public class ViewHolder { TextView text; public ViewHolder(TextView text) { this.text = text; } public TextView getText() { return text; } public void setText(TextView text) { this.text = text; } } Finally, we create our custom adapter overriding getViewTypeCount() and getItemViewType(int position). public class CustomAdapter extends ArrayAdapter { public static final int TYPE_ODD = 0; public static final int TYPE_EVEN = 1; public static final int TYPE_WHITE = 2; public static final int TYPE_BLACK = 3; private ListViewItem[] objects; @Override public int getViewTypeCount() { return 4; } @Override public int getItemViewType(int position) { return objects[position].getType(); } public CustomAdapter(Context context, int resource, ListViewItem[] objects) { super(context, resource, objects); this.objects = objects; } @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder viewHolder = null; ListViewItem listViewItem = objects[position]; int listViewItemType = getItemViewType(position); if (convertView == null) { if (listViewItemType == TYPE_EVEN) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_even, null); } else if (listViewItemType == TYPE_ODD) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_odd, null); } else if (listViewItemType == TYPE_WHITE) { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_white, null); } else { convertView = LayoutInflater.from(getContext()).inflate(R.layout.type_black, null); } TextView textView = (TextView) convertView.findViewById(R.id.text); viewHolder = new ViewHolder(textView); convertView.setTag(viewHolder); } else { viewHolder = (ViewHolder) convertView.getTag(); } viewHolder.getText().setText(listViewItem.getText()); return convertView; } } And our activity is something like this: public class MainActivity extends ActionBarActivity { private ListView listView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // here, you can create a single layout with a listview listView = (ListView) findViewById(R.id.listview); final ListViewItem[] items = new ListViewItem[40]; for (int i = 0; i adapterView, View view, int i, long l) { Toast.makeText(getBaseContext(), items[i].getText(), Toast.LENGTH_SHORT).show(); } }); } } See it on operation. That's it!","date":"2014-06-02T06:04:30.000Z","path":"multiple-layout-listview"},{"title":"Multitouch Test","image":"http://i.imgur.com/VGvkWzY.png","tags":["touch","google","play"],"content":"Multitouch Test is a simple app for Android to test the touch of your device. It measures and shows how accurate is the touch of your device, how many touches it supports, and there are some options to personalize the exhibition. After starting, just touch in screen with fingers that they will be recognized by the app. In Options Menu, there are 4 items for customization, they are: Colors Lines Numbers Coordinates Density Rings Vibration Watch a video while of its work!","date":"2012-03-27T02:15:54.000Z","path":"multitouch-test"},{"title":"Silence Please","image":"http://i.imgur.com/ZZUrAqY.png","tags":["url","silence","please","google","play"],"content":"Control the ambient sound by a sound level limit. When it is exceeded, the \"Silence Please\" will alert! Watch a video of its work!","date":"2013-08-14T19:16:30.000Z","path":"silence-please"},{"title":"Unshorten It","image":"http://i.imgur.com/vmgsz7e.png","tags":["url","unshortener","google","play"],"content":"This is a simple url unshortener. This is the first app implemented with the lib I developed Android Link Preview Watch a video of its work!","date":"2013-08-02T04:12:57.000Z","path":"url-unshortener"}]