[{"title":"7 Sorting Algorithms in a Few Lines","image":"http://i.imgur.com/yEK4JxE.png","tags":["sorting","sort","Java","algorithm"],"content":"So we will start it from the simplest ones to the hardest ones. Bubble Sort private static void bubbleSort(int[] v) { int i, j, n = v.length; for (i = 0; i v[j]) { swap(v, i, j); } } } } Selection Sort private static void selectionSort(int[] v) { int i, j, min, n = v.length; for (i = 0; i v[j]) min = j; } swap(v, min, i); } } Insertion Sort private static void insertionSort(int[] v) { int i, j, temp, n = v.length; for (i = 1; i = 0 && v[j] temp) { v[j + 1] = v[j]; j--; } v[j + 1] = temp; } } Shell Sort private static void shellSort(int[] v) { int n = v.length; int range = n / 2; int i, j, temp; int gap; while (range 0) { for (i = range; i = range && v[gap] temp) { v[j] = v[gap]; j -= range; gap = j - range; } v[j] = temp; } range /= 2; } } Heap Sort private static void heapify(int[] v, int pos, int n) { int low = 2 * pos + 1; int high = 2 * pos + 2; int largest, temp; if (low v[pos]) largest = low; else largest = pos; if (high v[largest]) largest = high; if (largest != pos) { temp = v[largest]; v[largest] = v[pos]; v[pos] = temp; heapify(v, largest, n); } } private static void heapSort(int[] v) { int n = v.length, i; int low = n / 2 - 1, high = n - 1; // Build initial heap for (i = low; i = 0; i--) { heapify(v, i, n); } for (i = high; i 0; i--) { swap(v, 0, i); heapify(v, 0, i); } } Quick Sort // Start with quickSort(v, 0, v.length - 1); private static int i; private static int j; private static void partition(int[] v, int low, int high) { i = low; j = high; int x = v[(i + j) / 2]; while (i x) j--; if (i i) quickSort(v, i, high); } Merge Sort // Start with mergeSort(v, 0, v.length - 1); private static void merge(int[] v, int low, int middle, int high) { int[] vAux = new int[v.length]; for (int i = low; i Swap Method private static void swap(int[] v, int i, int j) { int temp = v[i]; v[i] = v[j]; v[j] = temp; }","date":"2013-10-04T00:57:07.000Z","path":"7-sorting-algorithms-in-a-few-lines"},{"title":"AnnotationsOff","image":"http://i.imgur.com/CgYWr8r.png","tags":["chrome","extension","youtube"],"content":"You must find those text bubbles on Youtube videos boring just like me. So, this lightweight Chrome Extension was developed to remove all unwanted annotations and cards in Youtube videos making them clean and more pleasant to see. Enjoy it! The latest release you will always find it available on Chrome Web Store AnnotationsOff . Those are examples how it looks like with and without annotations and cards:","date":"2015-03-23T14:31:34.000Z","path":"annotationsoff"},{"title":"AVL Indexed Binary Heap","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","binary","tree","avl"],"content":"This approach is about Upgrade and Downgrade functions. In a normal Binary Heap, Upgrade and Downgrade are O(n) and it's expensive for us, so to improve that we use an AVL Tree to map the items and their positions on the Binary Tree. Thus, we can perform those functions in O(log n). Consider that there are no repeated indexes. Code snippets Below you will see a avl-indexed binary tree which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** value */ public int v; public Pair(int priority, int value) { this.p = priority; this.v = value; } @Override public String toString() { return \"[p=\" + p + \",v=\" + v + \"]\"; } } public class TreeNode { public int value; public TreeNode left; public TreeNode right; public TreeNode parent; public int key; public int balance; public TreeNode(int k, int v) { left = right = parent = null; balance = 0; key = k; value = v; } public TreeNode getLeft() { return left; } public void setLeft(TreeNode left) { this.left = left; } public TreeNode getRight() { return right; } public void setRight(TreeNode right) { this.right = right; } public TreeNode getParent() { return parent; } public void setParent(TreeNode parent) { this.parent = parent; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } } public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public void insert(int key, int value) { TreeNode n = new TreeNode(key, value); insertAvl(this.root, n); } /** Insert new node */ private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nKey \" + newNode.key + \" already exists. Ignoring...\"); } } } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the heaps.tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the heaps.tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } System.out.println(\"Left: \" + l + \" Key: \" + node.key + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } public TreeNode top() { return this.root; } public TreeNode left() { return this.root.left; } public TreeNode right() { return this.root.right; } /** * Calculates the Inorder traversal of this heaps.tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class BinaryHeapAvlIndexed { private AvlTree avlTree; /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeapAvlIndexed() { priorityType = HIGH; avlTree = new AvlTree(); } public BinaryHeapAvlIndexed(int type) { priorityType = type; avlTree = new AvlTree(); } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, 0); } public void swapHeapUpDown(ArrayList priorityQueue, Pair x, int position) { int currentPosition = position; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue.get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue.get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue.get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue.get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p + delta; /** Then, reorganize the priority queue over x */ swapHeapDownUp(priorityQueue, priorityQueue.get(pos), pos + 1); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue, int delta, Pair x) { /** Found the heaps.element, its priority will be changed */ TreeNode mapped = getAvlTree().find(x.v); if (mapped != null) { int pos = mapped.getValue() - 1; priorityQueue.get(pos).p = priorityQueue.get(pos).p - delta; /** Then, reorganize the priority queue over x */ swapHeapUpDown(priorityQueue, priorityQueue.get(pos), pos); /** Update position in the AVL heaps.tree */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Map the heaps.element index at the AVL heaps.tree */ public void map(ArrayList priorityQueue) { for (int i = 0; i priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue.set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } /** Get AvlTree */ public AvlTree getAvlTree() { return avlTree; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: /** Upgrade over the Pair(2, 3) */ binaryHeapAvlIndexed.upgrade(priorityQueue, 50, new Pair(2, 3)); /** Downgrade over the Pair(52, 3) */ binaryHeapAvlIndexed.dowgrade(priorityQueue, 37, new Pair(52, 3)); Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-08T19:05:00.000Z","path":"avl-indexed-binary-heap"},{"title":"AVL Tree","image":"http://i.imgur.com/1mMV9xR.jpg","tags":["java","tree","avl"],"content":"An AVL tree is balanced binary search tree. Its name contains the letters of its inventors, Adelson-Velskii and Landis, it was the first dynamically balanced tree to be proposed. The AVL trees may not be perfectly balanced, but pairs of sub-trees differ in height by at most 1, keeping an O (log N) search time. Addition and deletion operations also take O (log N) time. The following propositions define an AVL Tree: The subtrees of every node differ in height by at most one. Every subtree is an AVL tree. Search : Searching for a specific element in an AVL Tree can be done the same way as that of a normal unbalanced Binary Search Tree, that is: The searching starts by examining the root node. If the tree is null, the key we are searching for does not exist in the tree. Otherwise, if the key equals that of the root, the search is successful and we return the node. If the key is less than that of the root, we search the left subtree. Similarly, if the key is greater than that of the root, we search the right subtree. This process is repeated until the key is found or the remaining subtree is null. If the searched key is not found before a null subtree is reached, then the item must not be present in the tree. It can be a recursive or an iterative process. Insertion process is like the search; if the key is not equal to that of the root, we search the left or right subtrees as before. Eventually, we will reach an external node and add the new key-value pair as its right or left child, depending on the node's key. In other words, we examine the root and recursively insert the new node to the left subtree if its key is less than that of the root, or the right subtree if its key is greater than or equal to the root. After inserting a node, it is necessary to check each of the node's ancestors for consistency with the rules of Avl. And it is measured by the Balance Factor. The balance factor is calculated as follows: balanceFactor = height (left subtree) - height (right subtree). As the tree is balanced at every insertion (if necessary), the height of an AVL subtree cannot increase by more than one, so the temporary balance factor of a node will be in the range from âˆ’2 to +2. f the balance factor becomes less than âˆ’1 or greater than +1, the subtree rooted at this node is unbalanced, and rotations are necessary to make the tree balanced again. Rotations are operations that change the structure without interfering with the order of the elements. A tree rotation moves one node up in the tree and one node down. It is used to change the shape of the tree. The AVL Tree has 4 types of rotations: Right rotation : consists in rearranging clockwisely the positions of two nodes. Left rotation : consists in rearranging anticlockwisely the positions of two nodes. Right-Left rotation (AKA Double Right) : consists in rearranging clockwisely (first rotation) and anticlockwisely (second rotation) the positions of three nodes. Left-Right rotation (AKA Double Left) : consists in rearranging anticlockwisely (first rotation) and clockwisely (second rotation) the positions of three nodes. Sometimes a single rotation is not sufficient to balance an unbalanced tree, that's why the double rotations are needed. The first and second rotations are not performed on the same node. Source: Wikipedia Deletion : Like Insertion, the Deletion is similar to the Search. For deleted leaf nodes, clearly the heights of the children of the node do not change. Also, the heights of the children of a deleted node with one child do not change either. Hence, if a deletion causes a violation of the AVL Tree height property, this will occur on some node on the path from the parent of the deleted node to the root node. To restructure the tree after a deletion we will call the restructure method on the parent of the deleted node. Code snippets Below you will see a AVL Tree. public class TreeNode { public String value; public TreeNode left; public TreeNode right; public TreeNode parent; public int balance; public TreeNode(String v) { left = right = parent = null; balance = 0; value = v; } } public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** * Core Functions */ /** * Insert new node */ public void insert(String value) { TreeNode n = new TreeNode(value); insertAvl(this.root, n); } private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.value.compareTo(currentNode.value) 0) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nValue \" + newNode.value + \" already exists. Ignoring...\"); } } } /** * Finds a node */ public TreeNode find(String key) { currentSearchHeight = -1; return find(this.root, key); } /** * Finds a node */ public TreeNode find(TreeNode currentNode, String value) { currentSearchHeight++; if (value.equals(currentNode.value)) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (value.equals(currentNode.value)) return currentNode; else if (value.compareTo(currentNode.value) 0) return find(currentNode.right, value); else if (currentNode.left != null) return find(currentNode.left, value); else return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree */ public void remove(String k) { currentSearchHeight = -1; removeAvl(this.root, k); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, String searchingKey) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); } else { if (startingNode.value.compareTo(searchingKey) 0) { removeAvl(startingNode.left, searchingKey); } else if (startingNode.value.compareTo(searchingKey) = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { String l = \"0\"; String r = \"0\"; String p = \"0\"; if (node.left != null) { l = node.left.value; } if (node.right != null) { r = node.right.value; } if (node.parent != null) { p = node.parent.value; } System.out.println(\"Left: \" + l + \" Value: \" + node.value + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } public TreeNode top() { return this.root; } public TreeNode left() { return this.root.left; } public TreeNode right() { return this.root.right; } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","date":"2015-01-13T22:28:02.000Z","path":"avl-tree"},{"title":"Binary Heap","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","binary","heap"],"content":"A binary heap is a complete binary tree which follows the heap ordering property, that is all nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison rule defined. By design, there are two approaches of ordering that can be applied: min-heap: each element's priority ≥ its parent's priority. The minimum priority stands on the top. max-heap: each element's priority ≤ its parent's priority. The maximum priority stands on the top. Here, we consider the highest element on the top. Insertion is performed the last level and the last position of the heap. After that, the new element is compared to its parent and if there is inconsistency with their order, a rearrangement is made by changing positions of the child and the parent by using the method swapHeapDownUp . This task is done until it hits the root. Deletion is always performed at the top of the heap. The root element is popped out. The vacant root is taken by the element with the last element of the last level. Then, the new top element is compared with its two children and, if necessary, the replacement is performed changing the root with one of its children with the method we particularly called swapHeapUpDown and the last step is performed again. Upgrade and Downgrade: those functions increase or decrease the priority inside the elements, reorganizing the heap if necessary. Code snippets Below you will see a binary tree which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-08T18:21:56.000Z","path":"binary-heap"},{"title":"Closed Hashing","image":"http://i.imgur.com/KcnUKwx.png","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"content":"Collision resolution by Closed Hashing, also know as open addressing. Open Hashing can be considered a good strategy to resolve collisions, but the negative point is the need of an additional cost of memory to store the linked lists. On the other hand, Closed Hashing strategy allows all key-pair values to be stored in the hash table itself, then no extra cost of memory is needed. Collision Let's consider the insertion operation. The algorithm used it's logic (in our case, key modulus size table ) to find a empty slot (bucket), if the slot is not empty, than the algorithm keeps on searching an empty slot using a probe sequence until a free bucket is found or there's no empty slot anymore. The most used probe sequences are: inear probing - distance that the algorithm uses to search a new empty slot is constant (i.e. 1, the next slot); Quadratic probing - distance is current probe ² (i.e. 1² = 1, 2² = 4, 3² = 9...) and current probe lower than or equal to table size ; Double hashing - distance is calculated using another hash function; Rehashing - distance is calculated using linear or quadratic probing. But to grant that the key-pair value will be inserted, this approach uses a threshold. When this threshold is reached, the size of hash table is increased to the closest prime number of the double of its size. And all current key-pair values are arranged in the new size of the hash table before the new one is inserted. Linear probing Removal operation There are several nuances, when removing a key from hash table with open addressing. Consider following situation: Let's analyse. \"Andrew Wilson\" key has the same calculus of \"Jack Williams\" key, then the next slot the algorithm searched was the next one, but \"Sandra Miller\" key occupied that slot by calculus, then the algorithm searched the next slot, and finally it was empty and \"Jack Williams\" key was rearranged over there. If algorithm simply frees \"Sandra Miller\" slot, the structure of the table will get broken because the algorithm won't succeed trying to find \"Andrew Wilson\" key, since it uses the probe sequence . The slot contains different key and linear probing algorithm will try to find \"Andrew Wilson\" in the next slot, but it is empty, the reference was loss as you can see: The solution is as following. Instead of just erasing the key, the algorithm writes a special key-pair (-1, -1) value to the slot to flag that slot as DELETED. Now lookup algorithm will work properly. Insertion algorithm should reuse deleted slots, when possible: This algorithm resolves the problem, but with time hash table will become clogged with \"DELETED\" entries, which badly affects performance. If hash table should allow items removal, then Open Hashing is more preferable way to resolve collisions. Complexity analysis We call Load Factor the number that represents the complexity of a hash table. We can measure that simply as follows: number of entries / table size . If load factor exceeds 0.7 threshold, table's speed drastically degrades. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class ClosedHashingLinear { private final static int TABLE_INITIAL_SIZE = 8; private Node[] table; public ClosedHashingLinear() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = TABLE_INITIAL_SIZE) { /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); while (table[hash] != null && runner = TABLE_INITIAL_SIZE) { /** Not found */ } else { table[hash] = DeletedNode.getUniqueDeletedNode(); /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Code below implements quadratic probing. And also this implementation is protected against entering infinite loop. public class ClosedHashingQuadratic { private final static int TABLE_INITIAL_SIZE = 7; private Node[] table; public ClosedHashingQuadratic() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = edge) { /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); int edge = (int) Math.ceil((double) TABLE_INITIAL_SIZE / 2); while (table[hash] == null && runner = edge) { /** Not found */ } else { table[hash] = DeletedNode.getUniqueDeletedNode(); /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 18 will produce the following result: Linear 0. [31] 1. [55] 2. [37] 3. [ ] 4. [ ] 5. [23] 6. [24] 7. [6] 8. [42] 9. [ ] 10. [28] 11. [29] 12. [66] 13. [13] 14. [13] 15. [68] 16. [52] 17. [13] Quadratic 0. [ ] 1. [55] 2. [37] 3. [66] 4. [31] 5. [23] 6. [24] 7. [6] 8. [ ] 9. [ ] 10. [42] 11. [28] 12. [29] 13. [13] 14. [13] 15. [68] 16. [52] 17. [13] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Secondary images http://www.algolist.net/Data_structures/Hash_table/Open_addressing","date":"2013-10-13T18:31:52.000Z","path":"closed-hashing"},{"title":"Colorblinding","image":"http://i.imgur.com/iK49vgq.png","tags":["accessibility","chrome","extension"],"content":"Nowadays, accessibility is a frequent topic when technology is talked about. And this matter has always interested me, how technology can be used to make things better for all. Because according to Colour Blind Awareness , some of the types of color blindness affects approximately 1 in 12 men and 1 in 200 women in the world. So, I did a little research about how the websites are made to attend also a color vision impaired person and the different kinds of color blindness. Researching along, I've found some websites which allow us to upload a picture and see how they look like for a color vision impaired person, but not the website itself. So, It came up onto my mind \"What if we could apply filters on the website?!\". Fortunately, it's possible using SVG. The filters are made in SVG with the matrices of each filter corresponding to each color blindness, so the browser can multiply the values. The filters are applied to the website using CSS3 and jQuery. The matrices were calculated from here and SVG original file from here . After the researching, I started to make this Chrome Extension that displays in real time how your website can be seen by them, including images and videos. Colorblinding is working with the following types: Red-Blind / Protanopia Green-Blind / Deuteranopia Blue-Blind / Tritanopia Red-Weak / Protanomaly Green-Weak / Deuteranomaly Blue-Weak / Tritanomaly Monochromacy / Achromatopsia Blue Cone Monochromacy Note1: If the website already uses a filter in its css, the elements might change their original location when applying Colorblinding. To get them back, just select the option deactivate and refresh the page if it doesn't do it by itself. Note2: Colorblinding works in all tabs and the filter is applied when the tab is fully loaded . The latest release is always available on the Chrome Web Store Colorblinding . Those are examples how it looks like:","date":"2015-03-23T14:31:33.000Z","path":"colorblinding"},{"title":"Double Hashing","image":"http://i.imgur.com/KcnUKwx.png","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"content":"Collision resolution by Double Hashing. This strategy uses a second hash function to find a new empty slot in hash table. Like linear probing, it uses one hash value as an initial point and then repeatedly steps forward an interval until an empty slot is reached, or the entire table has been searched; but this interval is decided using a second, independent hash function (that's why its name is double hashing). Nevertheless, depending on the two hash functions that you create, the hash table cannot be completely mapped. And still If load factor exceeds 0.7 threshold, the hash table speed drastically degrades. The implementation below works as follows: The algorithm tries to insert the key into the hash table using its full size as parameter. If the key cannot be inserted, the analysis of the hash table size is changed to the prime number less than its size, and so on... Example: 17, 13, 11, 7, 5, 3, 2. In this case, 2 is the stop criteria for the tries. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class PrimeNumbers { public static int findClosestPrimeNumber(int number) { int previous = 0; int next = 0; for (int i = 0; i number) { int rangeDown = Math.abs(PRIME_NUMBERS[previous] - number); int rangeUp = Math.abs(PRIME_NUMBERS[next] - number); if (rangeDown number) { return PRIME_NUMBERS[previous]; } } else break; } return number; } /** Some prime numbers */ private static final int[] PRIME_NUMBERS = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209 }; } public class ClosedHashingDouble { private final static int TABLE_INITIAL_SIZE = 17; private Node[] table; public ClosedHashingDouble() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = TABLE_INITIAL_SIZE || (table[hash] != null && table[hash].getKey() != key && secondValue == 2)){ /** Not found */ } else { /** Found */ } } /** Remove item */ public void remove(int key) { /** Run along the array */ int runner = 0; int hash = (key % TABLE_INITIAL_SIZE); int secondValue = TABLE_INITIAL_SIZE; while (table[hash] == null || (table[hash] != null && (table[hash].getKey() != key)) && runner = TABLE_INITIAL_SIZE || (table[hash] != null && table[hash].getKey() != key && secondValue == 2)){ /** Not found */ } else { table[hash] = null; /** Removed */ } } private int countKeys() { int count = 0; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 17 will produce the following result: 0. [68] 1. [52] 2. [ ] 3. [37] 4. [55] 5. [ ] 6. [6] 7. [24] 8. [42] 9. [ ] 10. [23] 11. [28] 12. [29] 13. [13] 14. [31] 15. [66] 16. [ ] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Main image: http://www.algolist.net/Data_structures/Hash_table/Chaining","date":"2013-10-13T22:23:17.000Z","path":"double-hashing"},{"title":"Facebook Link Preview: PHP + jQuery (no longer maintained)\r\n","image":"http://i.imgur.com/XqaYUvI.png","tags":["Facebook","Link Preview","PHP","jQuery"],"content":"Disclaimer: I will no longer maintain this project because it's an old code and hard to maintain, but it's exported to AngularJS and Bootstrap. I believe this a great solution for an easy comprehension of the code and will allow the project to evolve even further. You can found this new project here >> Link-Preview All of us know about the big phenomenon that Facebook is. And since they have always to keep inovating, new super interesting features appear. And the liking of Facebook Link Preview is almost unanimous, it's activated when some url is inserted in the field where you update your status. Ok, it's cool But, have ever you stop to think how that works?! I did. And I got too curious. So, I started looking how to build one of it in PHP + Javascript , using jQuery , and could work like Facebook's and Google+ 's and it can checked out in the example below. As the most important part of the algorithm is in PHP, that is server-side, the capacity of servers that it will run can influence the speed of its execution. And we do not even have to comment about the giants' servers, since they are ones of the biggest technology companies in the world. The algorithm keeps tracking what you are typing in the status field and through regular expressions identifies a url. Thereafter, the text is in the field is passed to PHP that does all the work to analyze all the source code of the url found. If you enter more than one url, it will consider that the first one is the more relevant and it will create a preview. Once the source code of the url is obtained, regular expressions begin to seek out and capture relevant information on it. This information is basically the title page, the images contained therein, and a brief description of the content covered in the page. From the collection of information is assembled the page preview. I didn't speak more about the details of the code, giving examples of implementation, because the Link Preview is intrinsic to insert a url and generate the preview, but for developers who want to go further exploring the code, I'm providing the download of files with only one request: keep my reference in the codes, right?! I hope you enjoy! How to added onto your project Important: Make sure the library php5-curl is installed and enabled on the server, either locally or remotely. - Linux $ sudo apt-get install php5-curl $ sudo service apache2 restart - Mac (via macports ) $ sudo port install php5-curl $ sudo apachectl restart 1 • Scripts <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'</script <script src='js/linkPreview.js' </script <!-- If you are saving and fetching results from database using FLP, you can customize the layout on this script -- <script src='js/linkPreviewRetrieve.js' </script 2 • Stylesheets <!-- This stylesheet is provides the layout of Facebook’s former textarea. You can totally customize this! -- <link rel=\"stylesheet\" type=\"text/css\" href=\"css/linkPreview.css\" / 3 • Configuration Just create your own textarea (or multiple textareas) and bind it to jQuery like this: <script $(document).ready(function() { $('#lp1').linkPreview(); // changing placeholder $('#lp2').linkPreview({placeholder: \"Second Field\"}); // bind to a tag the results brought from database $('#retrieveFromDatabase').linkPreviewRetrieve(); }); </script Result Format { \"title\":\"title\", \"url\":\"original url\", \"pageUrl\":\"page url\", \"canonicalUrl\":\"cannonical url\", \"description\":\"description\", \"images\": \"img1|img2|...\", \"video\":\"yes|no\", \"videoIframe\":\"video iframe if it is video\" } Options option default value possible values function imageQuantity -1 any integer set the max amount of images to be brought (-1 for illimited) placeholder What's in your mind any string set the placeholder of textarea","date":"2012-10-07T01:09:40.000Z","path":"facebook-link-preview-php--jquery"},{"title":"Fibonacci Heap","image":"http://i.imgur.com/1mMV9xR.jpg","tags":["java","tree","fibonacci","leftist"],"content":"Fibonacci Heaps are collections of Leftist Trees . As those collections are part of a linked list, each element of the Fibonacci Heap has a pointer to the next element and a Leftist Tree. A new element is inserted into the top of the linked list at the leftist tree. If the top element's leftist tree and the next element's leftist tree have the same height, then a merge between them is performed. They are so called Fibonacci Heaps due to their frequency of merging. Code snippets Below you will see a Fibonacci Heap with Leftist Trees. public class LeftistTreeNode { public String value; public LeftistTreeNode left; public LeftistTreeNode right; public LeftistTreeNode parent; public LeftistTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class FibonacciHeapNode { public FibonacciHeapNode next; public LeftistTree tree; public FibonacciHeapNode(String value) { this.next = null; tree = new LeftistTree(); tree.insert(value); } } /** * Rules * 1. npl(left) = npl(right) * 2. prio(root) = prio(root.left) = prio(root.right) * Leftist tree is not a search structure, then it allows duplicate values */ public class LeftistTree { public LeftistTreeNode root; /** * Core Functions */ public void insert(String value) { LeftistTreeNode n = new LeftistTreeNode(value); insertLeftistTree(this.root, n); } /** * Insert new node */ private void insertLeftistTree(LeftistTreeNode currentNode, LeftistTreeNode newNode) { if (currentNode == null) { this.root = newNode; this.root.parent = null; } else { merge(currentNode, newNode); } } /** * Lazy merge: joins two left trees */ public void merge(LeftistTreeNode root, LeftistTreeNode newNode) { // Considering the tree.element with largest value on the top if (root.parent == null && root.value.compareTo(newNode.value) leftNpl || (rightNpl == leftNpl && leftValue.compareTo(rightValue) 0) { // invert here to change to small priority on top newRoot = toBeRemoved.left; newRoot.parent = null; merge(newRoot, toBeRemoved.right); this.root = newRoot; } else { newRoot = toBeRemoved.right; newRoot.parent = null; merge(newRoot, toBeRemoved.left); this.root = newRoot; } performSwap(this.root.right); System.out.println(\"\\nElement removed successfully.\"); } } } /** * Helper Functions */ public LeftistTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(LeftistTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Calculating the height of a node according to the root. */ public int heightRootToNode(LeftistTreeNode currentNode) { int height = 0; while (currentNode.parent != null) { height++; currentNode = currentNode.parent; } return height; } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(LeftistTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class FibonacciHeap { public FibonacciHeapNode root; /** * Core Functions */ /** * Insert new node */ public void insert(String value) { FibonacciHeapNode newNode = new FibonacciHeapNode(value); if (this.root == null) { this.root = newNode; } else { newNode.next = this.root; merge(newNode); } } public void find(String s) { int i = 0; FibonacciHeapNode root = this.root; LeftistTreeNode element; if (root != null) { do { element = root.tree.find(s); if (element != null) { System.out.println(\"Element with value \" + s + \" found in node \" + i); break; } i++; root = root.next; } while (root != null); } } /** * Removes the hight priority tree.element. It runs through the list. * */ public void remove() { if (this.root != null) { FibonacciHeapNode beforeHighestPriority = this.root; FibonacciHeapNode root = this.root.next; if (root == null) { this.root.tree.remove(); } else { do { if (beforeHighestPriority.tree.top().value.compareTo(root.tree.top().value) Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","date":"2015-01-14T02:10:11.000Z","path":"fibonacci-heap"},{"title":"Genetic Algorithm","image":"http://i.imgur.com/a2yW2cH.png","tags":["genetic","ga","algorithm","java"],"content":"A genetic algorithm (GA) is a very interesting and useful technique to find solutions for complex problems. These algorithms have that name because they are based in the behaviour of the genes, natural selection, mutation and crossover. They're commonly used to design computer algorithms to solve other optimization problems. Genetic algorithms work by mimicking the way life finds solutions to real world problems using the process of evolution. Although genetic algorithms are capable of solving incredibly complicated problems, they are way simple to understand. Candidate - Set a candidate solutiona, the optimum value. Initialization - Create an initial population with random individuals and each one with its own genetic code. Evaluation - Each member of the population is then evaluated and we calculate a 'fitness' for that individual. The fitness is calculated by how many similarities that the current individual, in analysis, have compared to the Candidate. Selection - For constantly improving the population's overall fitness, the best individuals must be selected for crossover and, then, create a new population closer to the Candidate. Crossover - During crossover we create new individuals by creating crosses of our selected individuals, the parents. The combination of these parents will create an even 'fitter' offspring for the next population which inherits the best genes of both individuals. Mutation - After the crossover, the mutation replaces some genes in the new individual. Otherwise, every combination in crossover will be the initial population, then the fitness would remain the same every evolution. And repeat it until find the optimum solution! Individual public class Individual { private byte[] genes = new byte[Main.defaultGeneLength]; private int fitness = -1; /** Create a random individual */ public void generateIndividual() { for (int i = 0; i Population public class Population { Individual[] individuals; /** Create a new population */ public Population(int populationSize, boolean initialize) { individuals = new Individual[populationSize]; /** * Initialize the population when it is not a population in evolving * process */ if (initialize) { /** Create the individuals */ for (int i = 0; i Fitness public class Fitness { static byte[] solution = new byte[Main.defaultGeneLength]; /** Set a candidate solution as a byte array */ public static void setSolution(byte[] newSolution) { solution = newSolution; } /** * Covert a candidate solution as a string to a candidate solution as a byte * array */ public static void setSolution(String newSolution) { solution = new byte[newSolution.length()]; /** * Run along the string converting its char as a byte */ for (int i = 0; i Algorithm public class Algorithm { /** Rate for maintaining of the originality */ private static final double uniformRate = 0.5; /** Rate allowed to mutate */ private static final double mutationRate = 0.015; /** Tournament set size */ private static final int tournamentSize = 5; /** Keep the fittest individual each evolution */ private static final boolean elitism = true; /** Evolve population */ public static Population evolvePopulation(Population population) { Population newPopulation = new Population(population.size(), false); /** * If elitism is wanted, then the best individual of this population * must be keeped */ int elitismOffset; if (elitism) { newPopulation.welcomeIndividual(0, population.getFittest()); elitismOffset = 1; } else elitismOffset = 0; /** Create a crossover in population individuals */ for (int i = elitismOffset; i Considering an initial population with 50 individuals and a genetic code 011101100000, the result in my machine was: Candidate Solution: 011101100000 **Initial Generation** Generation: 1 Fittest: -1 Genetic Code: 001001000100 Generation: 2 Fittest: 9 Genetic Code: 011101001100 Generation: 3 Fittest: 10 Genetic Code: 001111100000 Generation: 4 Fittest: 11 Genetic Code: 011001100000 **Optimum Solution** Generation: 5 Fittest: 12 Genetic Code: 011101100000 Idea derived and optimized from http://www.theprojectspot.com/tutorial-post/creating-a-genetic-algorithm-for-beginners/3","date":"2013-10-28T08:17:37.000Z","path":"genetic-algorithm"},{"title":"Git: Actual guide with actual examples","image":"http://i.imgur.com/KZeAkUA.png","tags":["git","scm","version","control"],"content":"Git is a free distributed revision control system for source code management (SCM). It is open source and designed to increase the speed and the efficiency on distributed and non-linear workflow projects. Additionally it improves its data integrity. You can download it from git-scm.com/downloads . First things first On Git world, you need to get used to some terms that will come up frequently. They are: repository : also shortened as “repo”, it's a directory where your project code will be managed and versionized. It can be local to a folder on your computer or it can be a storage space on an online host. commit : it's a command that create a \"snapshot\" of the current state of your repository in time, giving you a checkpoint to which you can analyse or restore your project to any previous state (other commits). commit hash : it's a SHA1 hash linked to a commit working as its id. Although its 40-digit-long size, you only need the 4 or 6 first chars to refer it. branch : branches are separate areas of development where you can work without interfering to each other. It's by this way that Git is collaborative. There's at least one branch in your repo and you should never work in a repository which other person is working on. You create a branch for you instead. staging area or index : a cache of files that you want to commit. An area where files added to index are enrolled. staged files: files prepared for a commit, added to index unstaged files: files not prepared to commit, not added to index. working directory : the root folder where you perform your coding. working copy : the folders and files that you’re currently using. It's always local. snapshot : it's a \"time registration\" of your project in time created by a commit. A \"version\". history : it's a \"book\" that contains everything of all the registrations of your project since your gitted it. Customizing Git configuration: git config This command allows you to configure your Git installation globally or on an individual repository. It can define from user info to preferences to the behavior of a repository. Below you'll find the most used git config commands. git config user.name <name and git config --global user.email <email define author's info that will be shown on commits and logs. $ git config --global user.name Leonardo Cardoso $ git config --global user.email leo@leocardz.com You also can create a shortcut to git command (e.g. 'git stage' as 'git add'). git config --global alias. $ git config --global alias.stage add $ git config --global alias.co commit $ git config --global alias.cane \"commit --amend --no-edit\" git co will work as git commit . You can choose your preferred editor. Git 's default one is vi . git config --global core.editor <editor Setting Sublime Text as default. $ git config --global core.editor \"subl -n -w\" Every next editing thing will be open on your preferred editor. Creating a repo: git init [--bare] To create a repository with a working directory where you can actually work, you simply need to use this command inside the directory: $ git init Initialized empty Git repository in ~/git_101/.git/ After creating it you will see that the directory contains a .git folder where all the git stuff goes and you will work at the level where the .git folder is. Bare repository is a git repository without a working directory, so you can’t work on it. Typically, when you are on a server, you have no need to have a working directory. Additionally, bare repositories are usually central repositories where all collaborators move their work to. It's a way to synchronize efforts between multiple people. $ git init --bare Initialized empty Git repository in ~/git_101_bare/ Cloning an existing repo: git clone [--bare] <repo [<directory] This command is similar to git init , but it clones a repo instead of creating one. Additionally, it creates a remote called 'origin' for the repo cloned from, sets up a local branch based on the remote's active branch (generally master), and creates remote-tracking branches for all the branches in the repo. $ mkdir git_102 $ git clone git_101 git_102 Cloning into 'git_102'... done. It works for bare repos as well: $ mkdir gg $ git clone --bare git@github.com:LeonardoCardoso/mvn-repo.git gg Cloning into bare repository 'gg'... remote: Counting objects: 24, done. remote: Compressing objects: 100% (11/11), done. remote: Total 24 (delta 1), reused 24 (delta 1) Receiving objects: 100% (24/24), 282.70 KiB | 125.00 KiB/s, done. Resolving deltas: 100% (1/1), done. Checking connectivity... done. Adding files to staging area: git add <file Let's create the file new_file.txt . It has to be created inside the working directory where you initialised git. git add <file $ vi new_file.txt $ git add new_file.txt By this doing, our new_file.txt is at the staging area and ready to be committed. To add all files that are not staged, use: $ git add . Removing files from staging area: git rm [--cached] <file To remove a file from staging area and/or tracking, use git rm [--cached] <file . $ git rm new_file.txt Caution: to remove all files, use: $ git rm . To remove file from version control and keep it in the working repository, use git rm --cached <file . $ git rm --cached new_file.txt Committing a file: git commit [-m] [<message] Committing a file is to tell Git to create a snapshot of the state of you project. All your added, modified, removed files since the last commit will have their status updated with this new commit. A message can be added to describe briefly what was changed. Let's commit our new_file.txt that we have already added: git commit -m <message $ git commit -m \"Initial commit\" [master (root-commit) 13abdd5] Initial commit 1 file changed, 1 insertion(+) create mode 100644 new_file.txt You also have the option to open your editor on commit. Just use: git commit $ vi .gitignore $ git add . gitignore $ git commit Editor will open. So you can add your message... .gitignored added # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # Changes to be committed: # new file: .gitignore # [master 44e0174] .gitignored added 1 file changed, 1 insertion(+) create mode 100644 .gitignore .gitignore: A special file .gitignore is a file that Git always looks before its commands. There you can tell git which files are not (and will be not) tracked. It's a simple text file and you can use regular expressions to block more than one file at once, like $ vi .gitignore Editor will open. So you can add your files which won't be tracked anymore... thisFileWillBeIgnored.txt # file ignored dir/ # entire directory ignored anotherDir/starting* # only files that start with \"starting\" inside anotherDir will be ignored *.jar # all jar files will be ignored If a file is already being tracked, you need to remove it, so it won't be tracked anymore. Otherwise, it will keep being tracked. Editting a commit: git commit --amend [[-m <message] [--no-edit]] This command is extremely useful because it allows you to change last commit info such as message or even adding or removing files. But, be aware! If your commit has already been pushed to remote repo, you have to force-pushing. You will learn about it later... If you noticed in our commit 13ab (hash), we added a message \".gitignored added\", but we want to change this message because the real name of the file is .gitignore. We can do it as follows: $ git commit --amend Your editor will open and you can change the message to “.gitignore added”, save it and close. [master 85c2310] .gitignore added 1 file changed, 1 insertion(+) create mode 100644 .gitignore You also can edit it inline using git commit --amend -m <message $ git commit --amend -m \".gitignore added\" [master 1d5a33b] .gitignore added 1 file changed, 1 insertion(+) create mode 100644 .gitignore If something was forgotten and you changed them but you don't want to change the commit message, you can do it using git commit -amend --no-edit . Showing details of a commit: git show <commit This command shows the details of a commit, like what files were added, modified and what was modified, removed. In our case, I created .gitignore file with the text \"thisFileWillBeIgnored.txt\". $ git show 85c2 commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added diff --git a/.gitignore b/.gitignore new file mode 100644 index 0000000..79591b7 --- /dev/null +++ b/.gitignore @@ -0,0 +1 @@ +thisFileWillBeIgnored.txt Viewing only the files that were changed in the last commit: git show --pretty=\"format:\" --name-only <commit git show --pretty=\"format:\" --name-only c158503 README Status of a repository: git status If you want to see the current status of the current branch your project, you can use git status to show that like listing which files are staged, unstaged, and untracked. git status lets you inspect the working directory and the staging area. $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) new_file2.txt nothing added to commit but untracked files present (use \"git add\" to track) Logging: git log This command displays committed snapshots and all their info. With it, you can list the project history, filter it, and search for specific changes. In contrast to git status , git log only operates on the committed history. $ git log commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added commit 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Author: Leonardo Cardoso <leo@leocardz.com> Date: Fri Jan 23 13:36:05 2015 +0000 Initial commit Showing changed files, just add --stat : $ git log --stat commit 85c23104b895497bf00bf59e964c48e152729150 Author: Leonardo <leo@leocardz.com> Date: Mon Jan 26 00:55:57 2015 +0000 .gitignore added .gitignore | 1 + 1 file changed, 1 insertion(+) commit 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Author: Leonardo Cardoso <leo@leocardz.com> Date: Fri Jan 23 13:36:05 2015 +0000 Initial commit new_file.txt | 1 + 1 file changed, 1 insertion(+) To shorten the messages excluding the empty lines, you can use git log --stat --oneline : $ git log --stat --oneline 85c2310 .gitignore added .gitignore | 1 + 1 file changed, 1 insertion(+) 13abdd5 Initial commit new_file.txt | 1 + 1 file changed, 1 insertion(+) Show messages formatted, just use --pretty=oneline. It also works for git show. $ git log --pretty=oneline 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit If you want to format a commit to a .patch file like to attach to an email, just use it: git format-patch -1 <commit $ git format-patch -1 85c2 0001-.gitignore-added.patch Showing who committed the staged file: git blame <file Git lets you show who manipulated a file by using git blame command. $ git blame new_file.txt 13abdd5 (Leonardo Cardoso 2015-01-23 13:36:05 +0000 1) First file Showing author's email instead the author's name: $ git blame -e new_file.txt 76a33985 (<leo@leocardz.com> 2015-01-26 01:27:05 +0000 1) Second file To show the changes in a subset of commits using hashes: $ git blame 76a3..13ab new_file.txt 13abdd5 (Leonardo Cardoso 2015-01-23 13:36:05 +0000 1) First file If the file is big, you can use regular expressions to know who included some block of code in it. $ git blame newest_file.txt 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 1) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 2) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 3) foo (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 4) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 5) } 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 6) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 7) bar (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 8) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 9) } 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 10) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 11) main (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 12) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 13) } $ git blame -L/^main/,/^}/ newest_file.txt 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 11) main (){ 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 12) 40bcf0d2 (Leonardo 2015-01-26 01:32:50 +0000 13) } Note: git blame only works on staged files. $ git blame thisFileWillBeIgnored.txt fatal: no such path 'thisFileWillBeIgnored.txt' in HEAD List branch files: git ls-files If you are a Unix-based SO user you certainly are familiar to ls command, or dir for Windows users. To list the files of the current branch, use the following command: $ git ls-files .gitignore new_file.txt newest_file.txt Viewing differences between two commits in a file: git diff git diff shows changes between commits, commit and working tree, etc. $ git diff diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. git diff HEAD shows the differences between the working directory and the most recent commit: $ git diff HEAD diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. If you added the files, but still want to view the difference to the last commit, git diff --cached lets you to see that. It shows difference between the staging area (index) and the last commit: $ git diff --cached diff --git a/README b/README index aad5bd..fd9e415 100644 --- a/README +++ b/README @@ -1 +1,2 @@ This is the README file. +One more line. Viewing differences between two commits in a file: git diff <hash..<hash <file $ git diff 76a3..13ab new_file.txt diff --git a/new_file.txt b/new_file.txt index 20d5b67..4c5fd91 100644 --- a/new_file.txt +++ b/new_file.txt @@ -1 +1 @@ -Second file +First file Creating branches: git branch One of the most important things on Git is branches. When you create a new branch, it will have the same history and files of the current branch which you created the one from unless you specify the commit. To create a new branch, just type: git branch <branch $ git branch developer To list branches, just use: git branch The * indicates the current branch your project is. $ git branch developer * master To list all branches, local and remote, just use: git branch -a $ git branch -a developer * master remotes/origin/developer remotes/origin/master To go to the new branch, just use: git checkout <branch $ git checkout developer Switched to branch ‘developer' To create a new branch from specified commit, just use: git checkout <branch <commit $ git branch new_branch_name 0aa034c Delete a branch: git branch -d <branch To delete a branch is simple: git branch -d <branch $ git branch -d developer Deleted branch developer (was 48f97a4). To force deletion, use a capital \"D\": git branch -D <branch Adding a remote repo: git remote This command lets you create, view, and delete connections to other repositories. It's most used to add the bare repository of your local repository. git remote add origin <path $ git remote add origin ../git_init_bare $ git remote add origin https://github.com/LeonardoCardoso/Movement.git To change the origin path of a already set origin, you can use the following command: git remote set-url origin <path $ git remote set-url origin ../git_101_bare To check the origin, just use: $ git remote -v origin ../git_101_bare (fetch) origin ../git_101_bare (push) Pushing to a repo: git push <remote <branch Pushing to a repo means to send all your local committed modifications to remote branch that you specify. It can be done by the following command: git push <remote <branch $ git push origin master Counting objects: 12, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (12/12), 1010 bytes | 0 bytes/s, done. Total 12 (delta 1), reused 0 (delta 0) To ../git_101_bare/ * [new branch] master - master You can also force a push by using one of the two commands: git push <remote <branch --force or git push -f <remote <branch $ git push origin master -f Warning: force-pushing will overwrite the remote branch with the state of your local one. If there are commits on remote branch that you don't have in your local branch, you will lose those commits. Warning: be cautious about amending commits that you have already shared with other people. Amending commits essentially rewrites them. So they will have different hashes, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to re-synchronize their work with your newly re-written commit, which can sometimes be difficult. So, although the usefulness of amending, avoid to do that if you shared the previous one with other Fetching a branch: git fetch <remote [<remote branch] [:<local branch] This command imports commits from a remote repository into your local repo. The resulting commits are stored as remote branches instead of the normal local branches. To fetch all branches from the origin repo. git fetch <remote $ git fetch origin Same as the above command, but only fetch the specified branch: git fetch <remote <remote branch $ git fetch origin developer If you want to fetch a branch and automatically create a local branch linked to it, use: git fetch <remote <remote branch:<local branch $ git fetch origin developer:dev From ../git_101_bare * branch developer - FETCH_HEAD Our last example will create a local branch named dev that links to developer . If you do not add the local branch on git command (:<local branch) , the branch will be fetched to your local repo as a remote branch, but no working copy branch will be created to link that. Pulling a branch: git pull <remote <branch git pull does a git fetch followed by a git merge . As told before, you can use git fetch at time you want to update your remote-tracking branches under refs/remotes/<remote. It won't affect your working copy though. However, if there is an update on a remote branch and your working copy branch is not up to date with the new modifications, but you want to bring the updates and automatically merge it, you can simply use: git pull <remote <branch $ git pull origin developer From ../git_101_bare * branch developer - FETCH_HEAD Already up-to-date. Merging branches: git merge <branch git merge is design to join two or more development histories together. To merge them, you can use: git merge <branch $ git checkout master $ git merge developer Updating 40bcf0d..9e97315 Fast-forward file_on_dev_branch.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file_on_dev_branch.txt The file we created on developer branch is brought to master branch. Manipulating Multiple Commits: git rebase This command allows you to edit multiple commits messages or join commits. The command is git rebase -i <commit . But, instead of using the commit hash, you can use HEAD~<number of commits that will show the previous N commits before the most recent one. For example: $ git rebase -i HEAD~3 $ git rebase -i 9e97 pick 40bcf0d newest_file.txt added pick 9e97315 Filed added on Dev branch pick 18b2e67 File on third branch # Rebase 76a3398..18b2e67 onto 76a3398 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out When you use this command, the commit you chose is selected. And all of the commits before it is listed and some explanations too. For example, we want to change the commit message of 9e97315. So, we only need to change the word pick at left side of 9e97315 to reword and save the file. After that, you file editor will be open to change the message. reword 9e97315 Filed added on Dev branch A new file added on Developer branch # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 76a3398 # You are currently editing a commit while rebasing branch 'third' on '76a3398'. # # Changes to be committed: # new file: file_on_dev_branch.txt # [detached HEAD b0c6af7] A new file added on Developer branch 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 file_on_dev_branch.txt Successfully rebased and updated refs/heads/developer. To check, let's log. $ git log --pretty=oneline 0648d95242ff6ea5705b344aa0c86f6d956d8888 One more file on dev b0c6af74e252828ae8b44791f5787b9f78ce3b6a A new file added on Developer branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit To join commits, you use squash . And the commit you will squash will be meld to the previous commit. And so will their changes. pick 85c2310 .gitignore added pick 76a3398 Changed content new_file.txt squash 40bcf0d newest_file.txt added pick b0c6af7 A new file added on Developer branch pick 0648d95 One more file on dev # Rebase 13abdd5..0648d95 onto 13abdd5 When you save the file, the file editor will be prompted. # This is a combination of 2 commits. # The first commit's message is: Changed content new_file.txt # This is the 2nd commit message: newest_file.txt added # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 13abdd5 # You are currently editing a commit while rebasing branch 'developer' on '13abdd5'. # # Changes to be committed: # modified: new_file.txt # new file: newest_file.txt # Here we removed those two commit messages and we put the message \"Squashed commit\" instead and save it. Squashed commit # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # rebase in progress; onto 13abdd5 # You are currently editing a commit while rebasing branch 'developer' on '13abdd5'. # # Changes to be committed: # modified: new_file.txt # new file: newest_file.txt # $ git log --pretty=oneline 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Revert to a previous Git commit using git revert This command undoes a committed snapshot. But, instead of removing the commit from the project history, it undoes the changes introduced by the commit and appends a new commit. This prevents Git from losing history, which is important for the integrity. $ git log --pretty=oneline dd0562dfca2fecf5c938857689a24a40fcb304ae Merge branch 'developer' of ../git_101_bare into developer 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit $ git revert 18b2 [developer 0494017] Revert \"File on third branch\" 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 file.txt $ git log --pretty=oneline 04940178e51e297cd577eab608a417850c430949 Revert \"File on third branch\" dd0562dfca2fecf5c938857689a24a40fcb304ae Merge branch 'developer' of ../git_101_bare into developer 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Revert to a previous Git commit using git checkout This command allows to checkout a branch (showed previously), paths to the working tree or take the branch to some commit in history. git checkout <commit $ git log --pretty=oneline 2ff5a4e099b7798787fe8e00167211c1e3e2afe2 One more file on dev e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit $ git checkout e6b0 HEAD is now at e6b0e3a... A new file added on Developer branch $ git log --pretty=oneline e6b0e3a59acf76cd41f53752178d6de9768a9247 A new file added on Developer branch da7176b55efd62e999a2a82e7f254d37498034c0 Squashed commit 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Undoing accidental deletions $ git checkout -f Force Git to overwrite local files: git reset If you want to throw out all of the changes you've been working on, you can use: $ git reset --HARD [<commit] If you don't insert the commit, it will be reseted to the most recent commit on remote. $ git reset --HARD 18b2 HEAD is now at 18b2e67 File on third branch $ git log --pretty=oneline 18b2e6771a04dc2ceabf9c4b2dcb4a00d9815eb5 File on third branch 9e97315bcbc29140db0a6d8245c5c7a69143cdda Filed added on Dev branch 40bcf0d2c74384cd6d0514883718ab25c162cd14 newest_file.txt added 76a339851ee01b5eedd9d787d232b4cc5da595cc Changed content new_file.txt 85c23104b895497bf00bf59e964c48e152729150 .gitignore added 13abdd57ba00fd53a4bf5dfeb054a2277eff5026 Initial commit Stashing modifications: git stash Stashing is a great way to pause what you’re currently working on and come back to it later. Suppose that we are making some changes and we are not done yet, but someone needs urgently that we fix some thing in some previous commit. So we can freeze our local modifications using: git stash $ git add . $ git stash Saved working directory and index state WIP on developer: 8178777 Merge branch 'developer' HEAD is now at 8178777 Merge branch 'developer' So, the files go back to state on the most recent commit on tracking. After we do the fixes, we just need to use git stash list to visualize the existing stashes. $ git stash list stash@{0}: WIP on (no branch): 2ff5a4e One more file on dev And to apply we use git stash apply stash@<stash number $ git stash apply stash@{0} On branch developer Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: one_more_file_on_dev.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") We can quickly apply the last stash using git stash pop . With this command, the applied stash is also deleted. Cleaning up untracked files: git clean Files may pile up in your working directory that are left over from merges, generated, or even put mistakenly there. No matter what, you don't need to ignore them in .gitignore, you just need to remove them. This command dries up the current branch. The following command will list the files to be removed: git clean -n -d <path $ git clean -n -d -x Would remove .DS_Store Would remove thisFileWillBeIgnored.txt The command to clean is git clean -i -d -x $ git clean -i -d -x Would remove the following items: .DS_Store thisFileWillBeIgnored.txt *** Commands *** 1: clean 2: filter by pattern 3: select by numbers 4: ask each 5: quit 6: help What now 1 Removing .DS_Store Removing thisFileWillBeIgnored.txt Bringing specific commit to current branch: git cherry-pick Cherry picking in git means to choose a commit from one branch and apply it onto another. So there is no need to merge the entire branch. Make sure you are in the right branch to cherry-pick the commit from another. git cherry-pick <commit-hash $ git cherry-pick 45fd Finished one cherry-pick. [master]: created 567ed1: “README file.\" 1 file changed, 1 insertions(+), 0 deletions(-) create mode 100644 README.txt Tagging releases: git tag Tags are used for creating stable releases. To do that, simply use the following code: git tag <version $ git tag 1.0 $ git push --tags Counting objects: 7, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 417 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To ../git_101_bare/ * [new tag] 1.0 - 1.0 $ git tag 2.0 $ git push origin tag 2.0 Total 0 (delta 0), reused 0 (delta 0) To ../git_101_bare/ * [new tag] 2.0 - 2.0 Listing tags: $ git tag -l 1.0 2.0 Logging the whole thing: git reflog Reflog is a mechanism which Git tracks the updates to the tip of branches. Even though the changesets are not referenced by any branch or tag. Thus, you can go back to them. After rewriting history, the reflog contains information about the old state of branches. $ git reflog 18b2e67 HEAD@{0}: checkout: moving from developer to third 48f97a4 HEAD@{1}: checkout: moving from master to developer 8178777 HEAD@{2}: checkout: moving from third to master 18b2e67 HEAD@{3}: checkout: moving from master to third 8178777 HEAD@{4}: merge developer: Merge made by the 'recursive' strategy. 18b2e67 HEAD@{5}: merge third: Fast-forward 9e97315 HEAD@{6}: checkout: moving from developer to master 48f97a4 HEAD@{7}: commit: One more file on dev 9e97315 HEAD@{8}: checkout: moving from master to developer 9e97315 HEAD@{9}: checkout: moving from third to master 18b2e67 HEAD@{10}: commit: File on third branch 9e97315 HEAD@{11}: checkout: moving from master to third 9e97315 HEAD@{12}: merge developer: Fast-forward 40bcf0d HEAD@{13}: checkout: moving from developer to master 9e97315 HEAD@{14}: commit: Filed added on Dev branch 40bcf0d HEAD@{15}: checkout: moving from master to developer 40bcf0d HEAD@{16}: commit: newest_file.txt added 76a3398 HEAD@{17}: commit: Changed content new_file.txt 85c2310 HEAD@{18}: commit (amend): .gitignore added 44e0174 HEAD@{19}: commit: .gitignored added 13abdd5 HEAD@{20}: commit (initial): Initial commit To go back to an old state, use git reset --hard <commit hash Resolving conflicts In many cases, you might see conflicts using Git . It consists basically of the same part of a file is changed on commits in two different branches without being updated before (merging). For example, if you make a change on a particular line in a file, and your colleague working in a repository makes a change on the exact same line, a merge conflict occurs. To solve that, you need to merge the file checking which differences must be remained in the file. After resolving the conflicts, you can add the file to index back again. A conflict-marked area begins with , the conflict markers. The two conflicting blocks themselves are divided by a =======. They need to be removed from the file after you inspect the file. 99db324742823c55d975b605e1fc22f4253a9b7d On this post, there are the main commands that you will use. But there are many others that you can check it out on its official documentation git-scm.com Complementary readings Git Howto: Revert a Commit Already Pushed to a Remote Repository","date":"2015-01-30T18:52:37.000Z","path":"git-actual-guide-with-actual-examples"},{"title":"GitHub Starred Repos Downloader","image":"http://i.imgur.com/XWAYwCu.jpg","tags":["GitHub","ruby"],"content":"gsrd downloads your public starred repos. Just in case you want to keep a backup of them from time to time. Configuration Getting your credential In order to keep your privacy, create your personal token on Github . You just need to select the option public_repo as shown below: Installation $ gem install gsrd Run Run the code passing your access token as argument $ gsrd \" put your forty character generated string here \" Requirement wget License The MIT License (MIT) Copyright (c) 2016 Leonardo Cardoso Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","date":"2016-07-14T18:10:27.000Z","path":"grsd"},{"title":"Half Open Hashing","image":"http://i.imgur.com/KcnUKwx.png","tags":["hashing","hash","algorithms","Java"],"content":"Approach This approach is a mix of Open Hashing with Avl and Rehashing , but the threshold in this case is the height of AVL tree. Addionatlly, it uses only the quadratic probing. Resizing There is a difference in the operation of resizing. If a data cannot be inserted due to the tree size or there's not empty slot (or still if an element is repeated in the tree, since AVL is a search data structure, which is why it does not accept repeated elements), the resize operation is performed. If an element already exists in the tree, it tries to find an empty slot using quadratic probing. Load Factor and Balancing Factor The Hash Table Load Factor in Half Open Hashing is the max height among the trees of hash table nodes. The Hash Table Balancing Factor in Half Open Hashing is the sum of the heights of the trees of hash table nodes divided by number of the size times max height (load factor) . Code snippets Below you will see a half open hashing. public class AvlTreeForHalfOpenHashing { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public boolean insert(int key, int value) { TreeNode n = new TreeNode(key, value); return insertAvl(this.root, n); } /** Insert new node */ private boolean insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key = currentNode.key) { if (newNode.key != currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } if (newNode.key == currentNode.key) { System.out.print(\"\\nKey \" + newNode.key + \" already exists on this tree. \"); return false; } } } return true; } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class AvlNodeForHalfOpenHashing { private int key; private int value; private AvlTreeForHalfOpenHashing avlTree; public AvlNodeForHalfOpenHashing(int key, int value) { this.avlTree = new AvlTreeForHalfOpenHashing(); this.avlTree.insert(key, value); this.key = key; this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public AvlTreeForHalfOpenHashing getAvlTree() { return avlTree; } public void setAvlTree(AvlTreeForHalfOpenHashing avlTree) { this.avlTree = avlTree; } } public class HalfOpenHashing { private final static int TABLE_INITIAL_SIZE = 13; /** In this case, the threshold is a max size of the tree */ private static final int THRESHOLD = 2; private static AvlNodeForHalfOpenHashing[] table; public HalfOpenHashing() { table = new AvlNodeForHalfOpenHashing[TABLE_INITIAL_SIZE]; for (int i = 0; i treeNodes = oldTable[i].getAvlTree() .inOrder(); for (TreeNode treeNode : treeNodes) { put(treeNode.getKey(), treeNode.getValue()); } } } } /** * The Hash Table Load Factor in Half Open Hashing is the max height among * the trees of hash table nodes */ public double loadFactor() { int maxHeight = 0; for (int i = 0; i maxHeight) { maxHeight = height; } } return maxHeight; } /** * The Hash Table Balancing Factor in Half Open Hashing is the sum of the * heights of the trees of hash table nodes divided by number of the size * times max height(load factor). (h1+h2+...+hn)/(TABLE_INITIAL_SIZE * H) */ public double balancingFactor() { double maxHeight = 0; double heightsSum = 0; for (int i = 0; i maxHeight) { maxHeight = height; } } return (heightsSum / ((double) table.length * maxHeight)); } public AvlNodeForHalfOpenHashing[] getTable() { return table; } } Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 13 and the threshold = 3 will produce the following result: Position 0. 13 \\ 52 Position 1. 13 \\ 66 Position 2. 28 Position 3. 55 / \\ / \\ 42 68 / 29 Position 4. 13 Position 5. 31 Position 6. 6 Position 7. [ ] Position 8. [ ] Position 9. [ ] Position 10. 23 Position 11. 24 \\ 37 Position 12. [ ] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","date":"2013-10-14T01:25:20.000Z","path":"half-open-hashing"},{"title":"Hash Table and Hashing Algorithms","image":"http://i.imgur.com/KcnUKwx.png","tags":["hash","hashing","algorithms","Java"],"content":"Hash Table Hash table (also hash map) is a data structure used to implement an associative array, a structure that can map keys to values. Implementally talking, hash table is an array-based data structure, which uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found. It's designed to keep insertion, deletion search with O(1) complexity. Hash Function Hash Function is the main feature of hash table design. It should assign each possible key to a unique slot. Although this ideal situation is rarely achievable in practice. Additionally, to offset this rarity different keys that are assigned by the hash function to the same bucket, called hash collisions, will occur and must be accommodated in some way. But if the hash function cause too many collisions, the hash table overall performance will be badly affected. Hash Table and Load Factor The load factor of a hash table is the ratio between the number of stored items and the array size. With its different implementations, hash table can whether be of a constant size or being dynamically resized, when load factor exceeds some threshold. Collisions What happens, if hash function returns the same hash value for different keys? It yields an effect, called collision. Collisions are practically unavoidable. Due to collisions, keys are also stored in the table, so one can distinguish between key-value pairs having the same hash. There are various ways of collision resolution. Basically, there are three different strategies with several branches: Open Hashing (also Closed addressing or Separate Chaining): Each slot of the hash table contains a link to another data structure (i.e. linked list or AVL tree), which stores key-value pairs with the same hash. When collision occures, this data structure is searched for key-value pair, which matches the key. Closed Hashing (also Open addressing): Each slot actually contains a key-value pair. When collision occurs, open addressing algorithm calculates another location (i.e. next one) with a linear or quadratic probing to locate a free slot. Another approach in Closed Hashing, called Rehashing that can be with linear or quadratic probing, is about resizing the hash table if some threshold is exceeded. Half Open Hashing (Mix of Open Hashing with AVL and Rehashing). Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","date":"2013-10-13T15:26:22.000Z","path":"hash-table-and-hashing-algorithms"},{"title":"Heap Sort","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","min","heap","sort","heapsort"],"content":"Heap Sort is a comparison-based algorithm and can be considered as an improvement of Selection Sort and like that Selection, it separates the input into to a sorted and an unsorted region, and at each interaction it shrinks the unsorted region by extracting the smallest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the minimum. Both algorithms along with 5 others can be found here . On this post, we use Heap Sort as a application of Priority Queues . That means that we have an unsorted Binary Heap and we use the Heap Sort to make it sorted. See its visualization: Source: Wikipedia Code snippets Below you will see heap sort which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } public class HeapSort { private BinaryHeap binaryHeap = new BinaryHeap(); private ArrayList priorityQueue = new ArrayList (); private Pair[] heapified; /** * Heap sort is simply to inheap the elements to priority queue, and outheap * elements */ public Pair[] sort(Pair[] set) { heapified = new Pair[set.length]; /** Build initial heap */ heapify(set); heapSort(); return heapified; } private void heapify(Pair[] set) { /** Heapifying */ for (int i = 0; i Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Before sorting After sorting Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-12T01:56:26.000Z","path":"heap-sort"},{"title":"An approach about i18n, PHP and AngularJS","image":"https://raw.githubusercontent.com/LeonardoCardoso/i18n-PHP-Angularjs/master/assets/php-angularjs-i18n.jpg","tags":["php","angularjs","i18n"],"content":"Basically, we use a cookie to set the current language, php classes to store the words for each language, and ajax calls to update the language. See how it works below... I18n.class.php This class is the base php class. It has all the base stuff like empty arrays and the base functions. The \"setUp()\" function, populates the main array \"var $i18n = [];\" with all the other ones in the class. The main function \"getLang($langRequests = [])\" will return the dictionary choosen by the user that was picked from the \"$i18n\" array. <?php class I18n { var $login = []; var $notFound = []; var $error = []; var $success = []; var $i18n = []; function setUp() { $this-i18n = [ \"login\" = $this-login, \"notFound\" = $this-notFound, \"error\" = $this-error, \"success\" = $this-success, ]; } function getLang($langRequests = []) { $this-setUp(); $result = []; foreach ($langRequests as $request) { $selection = $this-i18n[$request]; $result = array_merge($result, $selection); } return $result; } } ? ptBr.class.php This \"Language\" class extends the \"I18n\" class, with the custom messages in Portuguese. <?php include_once \"I18n.class.php\"; class Language extends I18n { function __construct() { $this-login = [ \"login\" = \"Fazer login\", // ... ]; $this-notFound = [ \"not_found_title\" = \"Página não encontrada\", // ... ]; $this-error = [ \"error_default_error\" = \"Algo inesperado ocorreu, tente novamente em instantes.\", // ... ]; $this-success = [ \"login_success\" = \"Login realizado com successo\", // ... ]; } } ? enUs.class.php This \"Language\" class extends the \"I18n\" class, with the custom messages in English. If you noticed, both \"ptBr.class.php\" and \"enUs.class.php\" files contain the same class called Language. This is so for keeping a generic way to get the dictionaries in the selected file. That class will be loaded in the next file \"lang.php\". <?php include_once \"I18n.class.php\"; class Language extends I18n { function __construct() { $this-login = [ \"login\" = \"Login\", ]; $this-notFound = [ \"not_found_title\" = \"Page not found\", ]; $this-error = [ \"error_default_error\" = \"Something unusual has happened, try again later.\", ]; $this-success = [ \"login_success\" = \"Successfully logged in\", ]; } } ? lang.php This file returns the dictionary on the file loaded by the cookie in JSON format. <?php $file = (isset($_COOKIE['i18n']) ? $_COOKIE['i18n'] : \"ptBr\") . \".class.php\"; $file = file_exists($file) ? $file : \"ptBr.class.php\"; include_once $file; $language = new Language(); echo json_encode($language-getLang($_POST[\"langRequests\"])); ? changeLanguage.php This file only sets the new language cookie. <?php $time = time() + (86400 * 30 * 365); // one year setcookie(\"i18n\", $_POST[\"lang\"], $time, \"/\"); ? app.js This file is the your Angular App file. var MyApp = angular.module('MyApp', []); lang.js This file contains a service that will check the JSON returned by the \"lang.php\" file and will change the {{(.*)}} key with its correspondent value. MyApp .service('langService', function() { var dictionary; var langService = {}; langService.i18n = function ($scope, $http, $langRequests) { $http.post('php/lang.php', { langRequests: $langRequests }).then(function (resp) { dictionary = resp.data; for (var k in dictionary){ if (dictionary.hasOwnProperty(k)) { $scope[k] = dictionary[k]; //console.log(k + \" - \" + dictionary[k]); } } }, function (err) { console.error('ERR', err); }) }; return langService; }); myController.js This file is your Angular Controller. You can do your stuff here, but the first action must be the language configurations. So you can say which arrays you want to be loaded in the current page. MyApp .controller('myController', ['$scope', '$http', 'langService', function($scope, $http, langService) { // select which messages group you want var $langRequests = [\"login\", \"notFound\", \"error\", \"success\"]; langService.i18n($scope, $http, $langRequests); $scope.languageSelect = function(lang) { $http.post('php/changeLanguage.php', { lang: lang }).then(function() { window.location = window.location; }) } } ]); Obs 1: The order of the files must be the following: <script src=\"https://dl.dropboxusercontent.com/s/js/angularjs/angular.min.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/app.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/lang.js\"></script> <script src=\"https://dl.dropboxusercontent.com/s/js/myController.js\"></script> Obs 2: The arrays you request in the myController.js variable \" var $langRequests = [];\" must be the same name as the i18n and its extended classes, like \"login\".","date":"2015-08-13T20:56:05.000Z","path":"i18n-php-angularjs"},{"title":"K-Numbers","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","numbers"],"content":"K-Numbers is a applied usage of Priority Queue . Its concept is about keep the smallest (or largest depending on the rule we want) k numbers on the top at each insertion into the heap. Insertion : given the set of numbers, we run the entire set and we inheap only the numbers less than (for the K-smallest) or greater than (for the K-largest) the contained ones already in the heap. Note that if the current interaction of the array is less than K, we simply add that element to the heap. The comparisons and necessary swaps are only performed when the array set is greater than K. Here, we use the algorithm to print our K-Numbers. Code snippets Below you will see a K-Numbers heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } /** Binary Heap */ /** Bigger priority is on the top as default */ public class BinaryHeap { /** For priorization with high priority on top */ public static final int HIGH = 0; /** For priorization with low priority on top */ public static final int LOW = 1; private int priorityType; public BinaryHeap() { priorityType = HIGH; } public BinaryHeap(int type) { priorityType = type; } /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** Outheap heaps.element in the top of priority queue */ public void outHeap(ArrayList priorityQueue) { Pair bottom = bottom(priorityQueue); /** * Remove the heaps.element in the top and insert the heaps.element in the bottom * into the top */ priorityQueue.set(0, bottom); priorityQueue.remove(priorityQueue.size() - 1); if (priorityQueue.size() 0) { /** Reorganize the priorities over the top */ Pair x = priorityQueue.get(0); swapHeapUpDown(priorityQueue, x); } } /** Reorganize the queue priority of heaps.element x, from up down */ public void swapHeapUpDown(ArrayList priorityQueue, Pair x) { int currentPosition = 0; int currentLeftPositon = 2 * currentPosition + 1; int currentRightPositon = 2 * currentPosition + 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it has reached the root. */ while (currentPosition 1) { if (priorityType == HIGH) { // High priorization if (currentLeftPositon = priorityQueue.size() || (currentRightPositon = priorityQueue .get(currentRightPositon).p))) { swap(priorityQueue, currentPosition + 1, currentLeftPositon + 1); currentPosition = currentLeftPositon; } else if (currentRightPositon priorityQueue .get(currentLeftPositon).p && (currentRightPositon = priorityQueue.size() || (currentRightPositon priorityQueue .get(currentRightPositon).p)) { swap(priorityQueue, currentPosition + 1, currentRightPositon + 1); currentPosition = currentRightPositon; } else { break; } } currentLeftPositon = 2 * currentPosition + 1; currentRightPositon = 2 * currentPosition + 2; } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root */ while (xParentPosition != 0 || (xParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p)) { if (priorityType == HIGH) { if (priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { /** Search the heaps.element to change its priority */ for (int i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Simple swap */ private void swap(ArrayList priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } /** The Smallest/largest k numbers (consider priorities) of a priority queue */ public class KNumbers { public static final int SMALLEST = 0, LARGEST = 1; private ArrayList kList = new ArrayList (); public ArrayList get(Pair[] set, int k, int type) { BinaryHeap binaryHeap = new BinaryHeap(type); int i = 0; /** Inheap the k first elements */ for (i = 0; i binaryHeap.top(kList).p) { kList.set(0, set[i]); binaryHeap.swapHeapUpDown(kList, binaryHeap.top(kList)); } } } return kList; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} and K = 3 will produce the following result: 3 Largest 3 Smallest Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-12T14:55:04.000Z","path":"k-numbers"},{"title":"Leftist Tree","image":"http://i.imgur.com/1mMV9xR.jpg","tags":["java","leftist","tree"],"content":"Leftist Tree is a binary tree which has always more elements at left than right. Its structure is controlled by a value called NPL (Null Path Length). Leftist Tree is not a search structure, then it allows duplicate values and in contrast to a binary heap, a leftist tree attempts to be very unbalanced. NPL (AKA s-value or rank) is the distance of level (height) of a node to the nearest leaf. If a node has no child or only one child, its NPL = 0; if its two children, its NPL = 1; and so on. The following propositions define an Leftist Tree: npl (child left) = npl (child right). priority (node) = priority (node.left) = priority (node.right). This priority can be the node value. Insertion : When inserting a new node into a tree, the new node considered as a tree to be merged into the existing tree. Deletion : To delete a minimum item, we remove the root and the left and right subtrees are then merged. Insertions and deletions take O (log N) time. The main advantage of Leftist Trees are their ability to merge quickly, compared to binary heaps which take O (N). Code snippets Below you will see a Leftist Tree. public class LeftistTreeNode { public String value; public LeftistTreeNode left; public LeftistTreeNode right; public LeftistTreeNode parent; public LeftistTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } /** * Rules * 1. npl(left) = npl(right) * 2. prio(root) = prio(root.left) = prio(root.right) * Leftist tree is not a search structure, then it allows duplicate values */ public class LeftistTree { public LeftistTreeNode root; /** * Core Functions */ public void insert(String value) { LeftistTreeNode n = new LeftistTreeNode(value); insertLeftistTree(this.root, n); } /** * Insert new node */ private void insertLeftistTree(LeftistTreeNode currentNode, LeftistTreeNode newNode) { if (currentNode == null) { this.root = newNode; this.root.parent = null; } else { merge(currentNode, newNode); } } /** * Lazy merge: joins two left trees */ public void merge(LeftistTreeNode root, LeftistTreeNode newNode) { // Considering the tree.element with largest value on the top if (root.parent == null && root.value.compareTo(newNode.value) leftNpl || (rightNpl == leftNpl && leftValue.compareTo(rightValue) 0) { // invert here to change to small priority on top newRoot = toBeRemoved.left; newRoot.parent = null; merge(newRoot, toBeRemoved.right); this.root = newRoot; } else { newRoot = toBeRemoved.right; newRoot.parent = null; merge(newRoot, toBeRemoved.left); this.root = newRoot; } performSwap(this.root.right); System.out.println(\"\\nElement removed successfully.\"); } } } /** * Helper Functions */ public LeftistTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(LeftistTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Calculating the height of a node according to the root. */ public int heightRootToNode(LeftistTreeNode currentNode) { int height = 0; while (currentNode.parent != null) { height++; currentNode = currentNode.parent; } return height; } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(LeftistTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","date":"2015-01-13T23:49:23.000Z","path":"leftist-tree"},{"title":"Link Preview: An AngularJS + Boostrap multilayout link previewer\r\n","image":"https://raw.githubusercontent.com/LeonardoCardoso/Link-Preview/master/demo/img/simple.png","tags":["Facebook","Link Preview","PHP","jQuery"],"content":"Hey, guys! This is the new version of Facebook Link Preview. It's built in AngularJS + Bootstrap. Lighter, faster, more beautiful and highly customizable. Let's go to the awesomeness! HTTP Server Apache (must support mod_php) How to add it to your project 1 • Stylesheets <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\" rel=\"stylesheet\" <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\" <link rel=\"stylesheet\" type=\"text/css\" href=\"src/link-preview/css/link-preview.css\" / 2 • Scripts <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\" type=\"text/javascript\"</script <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js\"</script <script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js\" type=\"text/javascript\"</script <script src=\"src/link-preview/js/link-preview.js\" type=\"text/javascript\"</script <!-- Include this script below if you want to retrieve the posts inserted to database -- <script src=\"src/link-preview/js/link-preview-database.js\" type=\"text/javascript\"</script 3 • Configuration Add the link preview module as a dependency to your application module: var app = angular.module('App', ['linkpreview']) Add the directive inside your controller html: <link-preview placeholder=\"What's in your mind?\" / Options att var default value possible values type type right right, left, bottom, top (text position) amount imageAmount -1 any integer btext buttonText Post any string bclass buttonClass primary default, primary, success, info, warning, danger, link cbtext cancelButtonText Cancel any string cbclass cancelButtonClass danger default, primary, success, info, warning, danger, link ltext loadingText Loading any string limage loadingImage empty.png any image url placeholder placeholder an empty string any string ttext thumbnailText Choose a thumbnail any string nttext noThumbnailText No thumbnail any string tpage thumbnailPagination %N of %N any string, %N is the number reference of pagination dtitle defaultTitle Enter a title any string ddescription defaultDescription Enter a description any string <link-preview type=\"\" ttext=\"\" tpage=\"\" placeholder=\"\" amount=\"\" limage=\"\" ltext=\"\" btext=\"\" bclass=\"\" ctext=\"\" cclass=\"\" dtitle=\"\" ddescription=\"\" / 4 • Database To custom your database configurations, you need to change the following values in Database.php $host = \"localhost\"; $user = \"\"; $password = \"\"; $database = \"linkpreview\"; Additionally, the way I used to retrieve the data was creating a controller link-preview-database.js which you can include the file somehow in your project or you can its content to yours. app.controller('MyControllerDatabase', ['$scope', '$http', function ($scope, $http) { $scope.databasePosts = []; $scope.retrieveFromDatabase = function () { // You must insert in your page a div with the posts retrieved from database. Just like the posts div // on template html files var url = 'src/link-preview/php/retrieve.php'; $http({ url: url, method: \"GET\", headers: {'Content-Type': 'application/x-www-form-urlencoded'} }).success(function (data, status, headers, config) { for (var i = 0; i Also, check the file database-template.php to see an example of how to display the data retrieved from database. Make sure your columns are the same as those ones in linkpreview.sql or customize them. Result Format { \"title\":\"title\", \"url\":\"original url\", \"pageUrl\":\"page url\", \"canonicalUrl\":\"canonical url\", \"description\":\"description\", \"images\": [\"array of images\"], \"image\": \"first image of images\", \"video\":\"true|false\", \"videoIframe\":\"video iframe, if it is a video\" } Important Make sure the library php5-curl is installed and enabled on the server, either locally or remotely. - Linux $ sudo apt-get install php5-curl $ sudo service apache2 restart - Mac (via macports) $ sudo port install php5-curl $ sudo apachectl restart","date":"2015-10-23T03:09:40.000Z","path":"link-preview"},{"title":"Min-Max Heap","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","min","max","heap"],"content":"Like a binary heap, Mix-max heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right. Unlike a binary heap, the nodes do not follow min-heap or max-heap, but a double-ended approach. The elements at and even level in the tree is less than all of its children, and the elements at an odd level is greater than all of its children. Min-max heaps has the properties of O(log n) insertion and deletion, can be built in time O(n), just like binary heaps. They are often represented implicitly in an array. Code snippets Below you will see a min max heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } public class MinMaxHeap { /** Inheap heaps.element x into priority queue */ public void inHeap(ArrayList priorityQueue, Pair x) { /** Add the pair x into priority queue */ priorityQueue.add(x); /** Check priority organization and reorganize if necessary */ swapHeapDownUp(priorityQueue, x); } /** * Outheap the highest heaps.element with the minimum priority of priority queue, * then put its grandchild with the largest priority in its place and the * bottom in the grandchilds place */ public void outHeapMin(ArrayList priorityQueue) { if (size(priorityQueue) 3) { int childIndex = 3; Pair bottom = bottom(priorityQueue); Pair grandChild2 = null; Pair grandChild3 = null; Pair grandChild4 = null; if (size(priorityQueue) 4) { grandChild2 = priorityQueue.get(4); if (grandChild2.p 5) { grandChild3 = priorityQueue.get(5); if (grandChild3.p 6) { grandChild4 = priorityQueue.get(6); if (grandChild4.p priorityQueue) { if (size(priorityQueue) 7) { int maxIndex1 = 1; int maxIndex2 = 2; int changeIndex = maxIndex1; Pair max1 = priorityQueue.get(maxIndex1); Pair max2 = priorityQueue.get(maxIndex2); int childIndex = 7; int childIndexOffset = childIndex; if (max1.p max2.p) { childIndex = (2 * maxIndex1 + 1) + (2 * maxIndex1 + 1) + 1; } else { childIndex = (2 * maxIndex2 + 1) + (2 * maxIndex2 + 1) + 1; changeIndex = maxIndex2; } Pair bottom = bottom(priorityQueue); Pair grandChild2 = null; Pair grandChild3 = null; Pair grandChild4 = null; if (size(priorityQueue) childIndexOffset + 1) { grandChild2 = priorityQueue.get(childIndexOffset + 1); if (grandChild2.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 1; } if (size(priorityQueue) childIndexOffset + 2) { grandChild3 = priorityQueue.get(childIndexOffset + 2); if (grandChild3.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 2; } if (size(priorityQueue) childIndexOffset + 3) { grandChild4 = priorityQueue.get(childIndexOffset + 3); if (grandChild4.p priorityQueue.get(childIndex).p) childIndex = childIndexOffset + 3; } priorityQueue.set(changeIndex, priorityQueue.get(childIndex)); priorityQueue.set(childIndex, bottom); priorityQueue.remove(priorityQueue.size() - 1); findChildren(priorityQueue, childIndex, true); } } /** Reorganize the queue priority of heaps.element x, from down up */ public void swapHeapDownUp(ArrayList priorityQueue, Pair x) { swapHeapDownUp(priorityQueue, x, priorityQueue.size()); } public void swapHeapDownUp(ArrayList priorityQueue, Pair x, int position) { int xPosition = position; int xParentPosition = xPosition / 2; int level = levels(xPosition); /** * Compare priority heaps.element to its parents priority and swap if * necessary if xParentPosition = 0, it reached the root * * Even levels keep the min priorities * * Odd levels keep the max priorities */ while (xParentPosition != 0) { int xGrandParentPosition = xParentPosition / 2; if (level % 2 == 0) { if (xGrandParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xParentPosition - 1).p) { swap(priorityQueue, xPosition, xParentPosition); } } else { if (xGrandParentPosition 0 && priorityQueue.get(xPosition - 1).p priorityQueue .get(xGrandParentPosition - 1).p) { swap(priorityQueue, xPosition, xGrandParentPosition); } else if (priorityQueue.get(xPosition - 1).p priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue, int delta, Pair x) { int i = 0; /** Search the heaps.element to change its priority */ for (i = 0; i priorityQueue) { return priorityQueue.get(0); } /** * Return the highest heaps.element with the maximum priority of priority queue */ public Pair topMax(ArrayList priorityQueue) { Pair x = priorityQueue.get(0); Pair left = x; Pair right = x; if (priorityQueue.size() 1) left = priorityQueue.get(1); if (priorityQueue.size() 2) right = priorityQueue.get(2); return (left.p right.p ? left : right); } /** * Return the number of levels of priority queue */ public int levels(int position) { return (int) (Math.log(position) / Math.log(2)); } /** * Return the number of elements of priority queue */ public int size(ArrayList priorityQueue) { return priorityQueue.size(); } /** * Return the heaps.element in the bottom */ public Pair bottom(ArrayList priorityQueue) { return priorityQueue.get(priorityQueue.size() - 1); } /** Reorganize children of an heaps.element */ private void findChildren(ArrayList priorityQueue, int elementPosition, boolean greaterThan) { int childIndex = elementPosition; int childLeftIndex = 2 * childIndex + 1; int childRightIndex = 2 * childIndex + 2; Pair grandChildLeft = null; Pair grandChildRight = null; if (childLeftIndex grandChildLeft.p) swapHeapDownUp(priorityQueue, grandChildRight, childRightIndex); else swapHeapDownUp(priorityQueue, grandChildLeft, childLeftIndex); } } else { if (grandChildLeft != null) { if (grandChildRight != null && grandChildRight.p priorityQueue, int xPosition, int xParentPosition) { Pair temp = priorityQueue.get(xPosition - 1); priorityQueue .set(xPosition - 1, priorityQueue.get(xParentPosition - 1)); priorityQueue.set(xParentPosition - 1, temp); } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)} will produce the following result: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-09T01:39:43.000Z","path":"min-max-heap"},{"title":"Movement","image":"http://i.imgur.com/YgCWvfU.gif","tags":["javascript","movement"],"content":"A funny way to interact with the mouse. It is excellent for Team showcases on your website. You can use a set of images to change according to mouse position on the screen. This way it gives the impressions of movement. It will work with devices with a pointer (mouse) in the screen. Have fun! Just follow the following simple steps to add it to your project 1 • Scripts <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'</script <script src='js/movement.js' </script 2 • Configuration Just create your own img tag (or multiple img tags ) with width and height specified whether inline or in css and bind it to jQuery like this: <img id=\"IMG ID\" style=\"width: 200px; height: 200px;\" <script $(document).ready(function() { $('IMG ID').movement({ center: \"http://i.imgur.com/tkStHbe.jpg\", up: \"http://i.imgur.com/cQ1YagQ.jpg\", upRight: \"http://i.imgur.com/8yVBOAZ.jpg\", right: \"http://i.imgur.com/7FccqSR.jpg\", downRight: \"http://i.imgur.com/CnIHIPB.jpg\", down: \"http://i.imgur.com/HbuZjKB.jpg\", downLeft: \"http://i.imgur.com/ve2uhtb.jpg\", left: \"http://i.imgur.com/rcaqqog.jpg\", upLeft: \"http://i.imgur.com/pOsZXC7.jpg\" }); }); </script option default value possible values center img/center.jpg any string up img/up.jpg any string upRight img/upRight.jpg any string right img/right.jpg any string downRight img/downRight.jpg any string down img/down.jpg any string downLeft img/downLeft.jpg any string upLeft img/upLeft.jpg any string","date":"2015-01-19T21:30:42.000Z","path":"movement"},{"title":"Open Hashing","image":"http://i.imgur.com/KcnUKwx.png","tags":["Java","algorithms","hash","hashing","Open Hashing"],"content":"Collision resolution by Open Hashing, also know as closed addressing or separate chaining. This approach is that each slot of the array contains a link to a linked list containing key-value pairs with the same hash. All new key-value pairs are added always to the end of the list. The search algorithm crawls through the list to find matching key of the givem hash. Initially table slots contain nulls until the first item is added. The time for hash table operations is the time to find the slot/bucket, which is O(1), plus the time for the list operation. Deletion is the same idea of Search, but when it finds the key and this key has a child, the algorithm links the found key child to its parent, if it's not the first item of the list. In a good hash table, each slot has zero or one entries, but at most three, because the optimized search can be affected with more values than that. Therefore, structures that are efficient in time and space for these cases are preferred. Illustration Code snippets Below you will see an open hashing with list heads. It means, that hash table entries store the elements themselves and not a pointer to it. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class OpenHashing { private final static int TABLE_INITIAL_SIZE = 7; private Node[] table; public OpenHashing() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 7 will produce the following result: 0. [42]-[28] 1. [29] 2. [23]-[37] 3. [24]-[52]-[66]-[31] 4. [ ] 5. [68] 6. [13]-[13]-[6]-[55]-[13] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing Secondary images http://www.algolist.net/Data_structures/Hash_table/Chaining","date":"2013-10-13T16:26:22.000Z","path":"open-hashing"},{"title":"Open Hashing with AVL","image":"http://i.imgur.com/KcnUKwx.png","tags":["hashing","hash","algorithms","Java","avl","tree","Open Hashing"],"content":"Approach This approach is similar to Open Hashing , but instead using a linked list to handle collision, it uses an AVL tree on each slot to decrease the vertical deep of the hash. Code snippets Below you will see an open hashing with avl tree. public class AvlTree { protected TreeNode root; public int currentSearchHeight = -1; /** Core Functions */ public void insert(int key, int value) { TreeNode n = new TreeNode(key, value); insertAvl(this.root, n); } /** Insert new node */ private void insertAvl(TreeNode currentNode, TreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.key currentNode.key) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; recursiveBalance(currentNode); } else { insertAvl(currentNode.right, newNode); } } else { System.out.println(\"\\nKey \" + newNode.key + \" already exists. Ignoring...\"); } } } /** Finds a node */ public TreeNode find(int key) { currentSearchHeight = -1; return find(this.root, key); } /** Finds a node */ public TreeNode find(TreeNode currentNode, int key) { currentSearchHeight++; if (key == currentNode.key) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (key == currentNode.key) return currentNode; else if (key currentNode.key) return find(currentNode.right, key); else if (currentNode.left != null) return find(currentNode.left, key); else return null; } return null; } else { return null; } } /** * Check the balance for each node recursively and call required methods for * balancing the tree until the root is reached. */ protected void recursiveBalance(TreeNode currentNode) { setBalance(currentNode); int balance = currentNode.balance; if (balance == -2) { if (height(currentNode.left.left) = height(currentNode.left.right)) { currentNode = rotateRight(currentNode); } else { currentNode = doubleRotateLeftRight(currentNode); } } else if (balance == 2) { if (height(currentNode.right.right) = height(currentNode.right.left)) { currentNode = rotateLeft(currentNode); } else { currentNode = doubleRotateRightLeft(currentNode); } } if (currentNode.parent != null) { recursiveBalance(currentNode.parent); } else { this.root = currentNode; } } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove(int k, int hash) { currentSearchHeight = -1; removeAvl(this.root, k, hash); } /** * Finds a node and calls a method to remove the node.. */ private void removeAvl(TreeNode startingNode, int searchingKey, int hash) { currentSearchHeight++; if (startingNode == null) { System.out.println(\"\\nKey \" + searchingKey + \" not found.\"); return; } else { if (startingNode.key searchingKey) { removeAvl(startingNode.left, searchingKey, hash); } else if (startingNode.key = b) { return a; } else { return b; } } /** * All information about a node. */ private void getAll(TreeNode node) { int l = 0; int r = 0; int p = 0; if (node.left != null) { l = node.left.key; } if (node.right != null) { r = node.right.key; } if (node.parent != null) { p = node.parent.key; } System.out.println(\"Left: \" + l + \" Key: \" + node.key + \" Right: \" + r + \" Parent: \" + p + \" Balance: \" + node.balance); if (node.left != null) { getAll(node.left); } if (node.right != null) { getAll(node.right); } } private void setBalance(TreeNode currentNode) { currentNode.balance = height(currentNode.right) - height(currentNode.left); } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(TreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } public class AvlNode { private int key; private int value; private AvlTree avlTree; public AvlNode(int key, int value) { this.avlTree = new AvlTree(); this.avlTree.insert(key, value); this.key = key; this.value = value; } public int getKey() { return key; } public void setKey(int key) { this.key = key; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public AvlTree getAvlTree() { return avlTree; } public void setAvlTree(AvlTree avlTree) { this.avlTree = avlTree; } } public class OpenAvlHashing { private final static int TABLE_INITIAL_SIZE = 7; private AvlNode[] table; public OpenAvlHashing() { table = new AvlNode[TABLE_INITIAL_SIZE]; for (int i = 0; i maxHeight) { maxHeight = height; } } return maxHeight; } /** * The Hash Table Balancing Factor in Half Open Hashing is the sum of the * heights of the trees of hash table nodes divided by number of the size * times max height(load factor). (h1+h2+...+hn)/(TABLE_INITIAL_SIZE * H) */ public double balancingFactor() { double maxHeight = 0; double heightsSum = 0; for (int i = 0; i maxHeight) maxHeight = height; } return (heightsSum / ((double) TABLE_INITIAL_SIZE * maxHeight)); } } Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 7 will produce the following result: Position 0. 42 / 28 Position 1. 29 Position 2. 23 \\ 37 Position 3. 52 / \\ / \\ 24 66 \\ 31 Position 4. [ ] Position 5. 68 Position 6. 13 / \\ 6 55 Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","date":"2013-10-13T17:23:15.000Z","path":"open-hashing-with-avl"},{"title":"Pix Color Analyzer","image":"http://i.imgur.com/wvTK9KE.jpg","tags":["image","java","pixel"],"content":"Library with the aim to analyze the pixel colors of an ARGB image. The picture above will generate a palette below. How to use that? Simple user the jar file. java -jar pca.jar [filename] [amount] You also can suppress amount. This way, the full palette will be generated. Obs.: For images that have many colors it can take a while to generate the window with the colors. java -jar pca.jar [filename] Palette Here the most dominant colors are printed in descending order","date":"2014-10-03T08:40:26.000Z","path":"pix-color-analyzer"},{"title":"Priority Queues","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java"],"content":"A priority queue is an abstract data type which is like a regular queue or stack data structure where each element has a priority attached. In it, the FIFO (first-in-first-out) rule is not necessarily followed. An element with a higher priority is taken before an element with lower priority. If two elements have the same priority, they are taken according to their order in the queue. An element can be inserted into a priority queue at any time, but only the element with highest priority can be retrieved for operations. The Priority Queue concept can be implemented in many different ways in different data structures. The structures with the best efficiency of priority queues are the heaps. Here we are gonna show some of them... Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap Avl Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-07T15:30:27.000Z","path":"priority-queues"},{"title":"Radix Heap","image":"http://i.imgur.com/8DJn3OA.jpg","tags":["priority","queue","java","radix","sort","radixsort"],"content":"Radix Heap is the process to organize a PQ reducing its medium complexity of heap operation at the maximum. In this case, the PQ is divided in ranked pieces. Insertion and Deletion are made according to the ranks, from the smallest to the largest or vice versa while the priority is being treated. To create the ranks, first the largest priority must be know and the ranks can be as follows: [2^1][2^2][2^3][...][2^k] K is the power when 2^k is the first number greater than the largest priority. Then priorities lower than or equals 2^1 will be allocated in the first priority queue. Priorities greater than 2^1 and lower than 2^2 will be allocated in the second priority queue. And so on... Code snippets Below you will see a radix heap which each element has two integers, first is the priority and the second is the value. public class Pair { /** priority */ public int p; /** index */ public int i; public Pair(int priority, int index) { this.p = priority; this.i = index; } @Override public String toString() { return \"[p=\" + p + \",i=\" + i + \"]\"; } } public class RadixHeap { private ArrayList [] radixSet; private final int[] POWERS_OF_TWO = { 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824 }; public void organize(Pair[] set) { BinaryHeap binaryHeap = new BinaryHeap(BinaryHeap.LOW); int largestPriority = getLargestPriority(set); int kPower = getKPower(largestPriority); /** Initiate the radixSet */ radixSet = new ArrayList[kPower]; for (int i = 0; i (); /** Distribute elements to the correct priority queue */ for (int i = 0; i [] getRadixSet() { return radixSet; } /** Calculate the k power */ private int getKPower(int priority) { int k = 0; if (priority POWERS_OF_TWO[POWERS_OF_TWO.length - 1]) { k = POWERS_OF_TWO.length + 1; } else { for (int i = 1; i POWERS_OF_TWO[i - 1] && priority largestPriority) largestPriority = set[i].p; } return largestPriority; } } Using this code with these entries Pair[] SET = {new Pair(2, 3), new Pair(21, 4), new Pair(3, 9), new Pair(16, 16), new Pair(4, 4), new Pair(9, 2), new Pair(21, 7), new Pair(31, 9), new Pair(3, 3)}: Below there are links to all implementations of several applications of Priority Queue concept. Heaps Priority Queue Binary Heap AVL Indexed Binary Heap Min-Max Heap Radix Heap Usage Heap Sort K-Numbers (Smallest/Largest k numbers of the priority queue)","date":"2015-01-12T15:25:54.000Z","path":"radix-heap"},{"title":"Rehashing","image":"http://i.imgur.com/KcnUKwx.png","tags":["hashing","hash","algorithms","Java","Closed Hashing"],"content":"Collision resolution by Rehashing. As explained on Closed Hashing section, the calculus to find an empty slot is calculated using linear or quadratic probing. But to grant that the key-pair value will be inserted, this approach uses a threshold. When this threshold is reached, the size of hash table is increased to the closest prime number of the double of its size. And all current key-pair values are arranged in the new size of the hash table before the new one is inserted. Rehashing has positive and negative points. One of positive is the load factor is always under the threshold, and performance is really good; and of negative is that hash table can have a lot of unused empty spaces, increasing memory cost. Removal operation Like Closed Hashing, instead of just erasing the key, the algorithm writes a special key-pair (-1, -1) value to the slot to flag that slot as DELETED. Now lookup algorithm will work properly. Insertion algorithm should reuse deleted slots, when possible. Code snippets Code below implements linear probing. Current implementation is protected against entering infinite loop. public class Node { private int key; private int value; private Node next; public Node(int key, int value) { this.key = key; this.value = value; this.next = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public int getKey() { return key; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } } public class PrimeNumbers { public static int findClosestPrimeNumber(int number) { int previous = 0; int next = 0; for (int i = 0; i number) { int rangeDown = Math.abs(PRIME_NUMBERS[previous] - number); int rangeUp = Math.abs(PRIME_NUMBERS[next] - number); if (rangeDown number) { return PRIME_NUMBERS[previous]; } } else break; } return number; } /** Some prime numbers */ private static final int[] PRIME_NUMBERS = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209 }; } public class RehashingLinear { private final int TABLE_INITIAL_SIZE = 11; private float threshold = 0.70f; private int maxSize = (int) (TABLE_INITIAL_SIZE * threshold); private int size = 0; private Node[] table; public RehashingLinear() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = maxSize) { resize(); } } /** Get item */ public void get(int key) { /** Run along the array */ int runner = 0; int hash = (key % table.length); while (table[hash] != null && runner Code below implements quadratic probing. And also this implementation is protected against entering infinite loop. public class RehashingQuadratic { private final int TABLE_INITIAL_SIZE = 11; private float threshold = 0.70f; private int maxSize = (int) (TABLE_INITIAL_SIZE * threshold); private int size = 0; private Node[] table; public RehashingQuadratic() { table = new Node[TABLE_INITIAL_SIZE]; for (int i = 0; i = maxSize) { resize(); } } /** Get item */ public void get(int key) { /** Run along the array */ int runner = 0; int hash = (key % table.length); /** * Quadratic probing only grants an element insertion while runner is * under the half of the table size. */ int edge = (int) Math.ceil((double) table.length / 2); while (table[hash] != null && runner Using this code with these entries { 13, 13, 24, 6, 23, 55, 42, 28, 37, 52, 68, 29, 13, 66, 31 } and the hash table size = 11 and the threshold = 0.7 will produce the following result: Linear 0. [23] 1. [24] 2. [ ] 3. [ ] 4. [ ] 5. [28] 6. [6] 7. [52] 8. [29] 9. [55] 10. [31] 11. [ ] 12. [ ] 13. [13] 14. [13] 15. [37] 16. [13] 17. [ ] 18. [ ] 19. [42] 20. [66] 21. [ ] 22. [68] Quadratic 0. [23] 1. [24] 2. [ ] 3. [ ] 4. [ ] 5. [28] 6. [6] 7. [52] 8. [31] 9. [55] 10. [29] 11. [ ] 12. [ ] 13. [13] 14. [13] 15. [37] 16. [ ] 17. [13] 18. [ ] 19. [42] 20. [66] 21. [ ] 22. [68] Below there are links to all implementations of hashing algorithms. Open Hashing Open Hashing with Avl Closed Hashing Linear probing Quadratic probing Double hashing Rehashing Linear probing Quadratic probing Half Open Hashing","date":"2013-10-13T23:23:19.000Z","path":"rehashing"},{"title":"Rotate and Scale: jQuery","image":"http://i.imgur.com/chj33Yl.png","tags":["jQuery","Scale","Rotate"],"content":"If you liked Scale and Rotate , you will probably like this jQuery plugin too. It's the mix of both. It's the same simple and useful usage. Options option default value possible values function event click, mouseover event which the animation will start at action increase increase, decrease animation behavior howMany 20 any integer how many times the element will be increased or decreased initialSize element width any integer starting width finalSize element width any integer final width pixels 1 any integer how many pixels will be increased or decreased at once rotateAndScaleTime 0 any integer animation speed in milliseconds keepScaling no yes, no if keepScalling is equal to yes, the animation will stop at inicialSize + howMany ou inicialSize - howMany frequency one one, continuous if frequency is equal to continuous, the animation will keep being performed until there is a stop condition, if there's not it'll be performed forever plane both vertical, horizontal orientation of animation way right right, left animation way time 0 any integer performing time in milliseconds speed 1 any integer animation speed (how many pixels will be rotated at once) degrees any integer between 0 and 360 how many degrees to be rotated $('#rotateAndScale').rotateAndScale(); $('#foo').rotateAndScale({event: \"click\", action: 'decrease'}); $('#bar').rotateAndScale({event: \"mouseover\", howMany: '40', rotateAndScaleTime: 50}); $('#leo').rotateAndScale({event: \"click\", howMany: '10', frequency: 'continuous'}); $('#hrz').rotateAndScale({way: \"left\", frequency: 'continuous', plane: 'horizontal', rotateAndScaleTime: 25}); $('#vrt').rotateAndScale({frequency: 'continuous', plane: 'vertical', action: 'decrease'}); $('#clock').rotateAndScale({way: \"left\", frequency: 'continuous', rotateAndScaleTime: 1000, pixels: 3});","date":"2012-05-25T01:10:09.000Z","path":"rotate-and-scale-jquery"},{"title":"Rotate: jQuery","image":"http://i.imgur.com/LMmnB15.png","tags":["jQuery","Rotate"],"content":"Just like Scale , this post introduces a simple and useful jQuery plugin made by me that rotates whatever elements you want. It changes the element style. Below you can see how many different ways you can use it and see its default and possible values that can be assumed. Have you ever seen the time by a Chrome clock?! : : Options option default value possible values function event click, mouseover event which the animation will start at way right right, left animation way time 0 any integer performing time in milliseconds speed 1 any integer animation speed (how many pixels will be rotated at once) degrees any integer between 0 and 360 how many degrees to be rotated clock no yes, no to assume the position of a clock hour no yes, no clock hours minute no yes, no clock minutes second no yes, no clock seconds $('#chrome').rotate(); $('#chromium').rotate({way: 'left', speed: 3}); $('#chrome1').rotate({way: 'left', event: 'mouseover'}); $('#chromium1').rotate({event: \"click\", way: 'right', speed: 15}); $('#chrome2').rotate({time: 1000, speed: 6}); $('#chromium2').rotate({event: \"mouseover\", degrees: 180, time: 10, speed: 5}); $('#rotate').rotate({event: \"click\", degrees: 90});","date":"2012-03-19T03:47:13.000Z","path":"rotate-jquery"},{"title":"Scale: jQuery","image":"http://i.imgur.com/qdEbUgw.png","tags":["jQuery","Scale"],"content":"This post introduces a simple and useful jQuery plugin made by me that scales whatever elements you want. It changes the element style. Below you can see how many different ways you can use it and see its default and possible values that can be assumed. Don't forget to declare element width and height in css ou in style (this is fundamental) . Options option default value possible values function event click, mouseover event which the animation will start at action increase increase, decrease animation behavior howMany 20 any integer how many times the element will be increased or decreased initialSize element width any integer starting width finalSize element width any integer final width pixels 1 any integer how many pixels will be increased or decreased at once scaleTime 0 any integer animation speed in milliseconds keepScaling no yes, no if keepScalling is equal to yes, the animation will stop at inicialSize + howMany ou inicialSize - howMany frequency one one, continuous if frequency is equal to continuous, the animation will keep being performed until there is a stop condition, if there's not it'll be performed forever plane both vertical, horizontal orientation of animation $('#scale').scale(); $('#chrome').scale({event: \"click\"}); $('#foo').scale({event: \"click\", action: 'decrease'}); $('#bar').scale({event: \"mouseover\", howMany: '40', scaleTime: 50}); $('#leo').scale({event: \"click\", howMany: '10', frequency: 'continuous'}); $('#hrz').scale({frequency: 'continuous', plane: 'horizontal', scaleTime: 25}); $('#vrt').scale({action: 'decrease', frequency: 'continuous', plane: 'vertical'}); $('#clock').scale({frequency: 'continuous', scaleTime: 1000, pixels: 3});","date":"2012-03-14T02:56:31.000Z","path":"scale-jquery"},{"title":"Single Compilation Unit: C/C++","image":"http://i.imgur.com/Zkr1fX1.png","tags":["C/C++","Programming"],"content":"Single Compilation Unit , also known as Separate Compilation , is a technique of the programming languages C/C++ that allows to reduce the compilation time and aims to help the compiler to perform optimization of the program, even when the compiler itself doesn't support the optimization of the entire program or precompiled headers. Generally, a C/C++ development environment assumes that .c/.cpp source files are preprocessed (the moment which the compiler expands the source file and includes all the headers described in the file, in other words, creating of translation units) and translated separately by the compiler, generating object code files (.o or .obj), which can then be linked together to create a executable library or file (.exe on Windows , for example). This process leads to several passages that are being performed in header files (.h) common, and with C++, multiple template instantiations of the same template in different translation units, thus having a replication code. The Separate Compilation technique uses preprocessor directives to \"stick\" different translation units at compile time, not at link time. Thus, reducing the overall compile time, but increasing the time needed to build after making small changes in any source file included in a single compilation unit. Therefore, the less the source files need to be modified best performance of this technique. CS also allows an optimizer to draw inner relationships between the functions, thus allowing optimizations such as creating inline functions (the copy function they are called in some other block of the program to this block where they are called). It also helps to avoid the implicit code bloat due to exceptions, side effects and register allocation, which are generally neglected by the classical scheme of using separate modules and not always achieved by the use of precompiled headers. Below is an example of separate compilation in C++, but in download files there's an example in C too: 1º - You must have a header file (.h) and insert in it only class and functions declarations, the scope will be defined in its .cpp correspondent file. The directives #ifndef #define #endif guarantee that if the preprocessor macro SEPARATECOMPILATION_H is already defined, the block inside its correspondent #ifndef will be ignored in the rest of the code, preventing this block to be processed more than once. #ifndef SEPARATECOMPILATION_H #define SEPARATECOMPILATION_H class fibonacci{ public: long long int numberCalculus(int); ~fibonacci(){}; }; #endif 2º - In the correspondent .cpp file to the .h file the scope of the class functions is defined, in this case. #include \"separateCompilation.h\" long long int fibonacci::numberCalculus(int number){ long long int temporary; int i; if(number == 0) temporary = 0; else if(number == 1 || number == 2) temporary = 1; else{ long long int before = 1, beforeBefore = 1; for(i = 2; i < number; i++){ temporary = beforeBefore + before; beforeBefore = before; before = temporary; } } return temporary; } 3º - In the end, you include the header file in the file that contains the main function. #include <iostream> #include \"separateCompilation.h\" using namespace std; int main(){ int userNumber; fibonacci fib; long long int result; cout << \"\\nEnter a number to calculate its Fibonacci number: \"; cin >> userNumber; result = fib.numberCalculus(userNumber); cout << \"\\n\"; if(result == -1){ cout << \"Invalid Number\"; } else if(result < -1){ cout << \"Result overflows long long int: \" << result; } else{ cout << \"Result is \" << result; } cout << \"\\n\\n\"; return 0; } Now, just compile all files .cpp and run the program. On Linux and Mac, you can use the g++ compiler to compile all .cpp files as follows: g++ on bash Now, the header file separateCompilation.h is compiled only once, and the function fibonacci::numberCalculus(int number) can be inlined directly in its class, despite being in another file.","date":"2012-03-13T04:33:16.000Z","path":"single-compilation-unit-cc"},{"title":"Splay Tree","image":"http://i.imgur.com/1mMV9xR.jpg","tags":["java","splay","tree"],"content":"Splay Tree is a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again, so they are splayed to the top. It performs basic operations such as insertion, search and removal in O(log n) amortised time. The elements are organised topologically to favour one access condition to the information or even to reduce the process complexity. Insertion is performed like a normal binary search, then the new node is splayed to the top. Deletion is also like a binary search tree with a slight difference: if the node has two children, swap its value with that of either the rightmost node of its left subtree or the leftmost node of its right subtree. Then remove that node. In this way, deletion is reduced to the problem of removing a node with 0 or 1 children. Differently of a binary search tree, in a splay tree after deletion, we splay the parent of the removed node to the top of the tree. Search it is a binary search as well, but after the access, we splay the element to the top to be more fast accessible next time. Rotations in Splay Tree are six: zig and zag : they are single right rotation and single left rotation respectively. The target element is lifted up by one level. zig-zag and zag-zig : double right rotation and double left rotation, like Avl double rotations . The target element is lifted up by two levels. zig-zig and zag-zag : they are also double rotations but instead alternating the directions of each rotations in it, the perform two rotations to right (zig-zig) and to rotations to left (zag-zag). And also the target element is lifted up by two levels Code snippets Below you will see a Splay Tree. public class SplayTreeNode { public String value; public SplayTreeNode left; public SplayTreeNode right; public SplayTreeNode parent; public SplayTreeNode(SplayTreeNode splayTreeNode) { if (splayTreeNode != null) { this.value = splayTreeNode.value; this.left = splayTreeNode.left; this.right = splayTreeNode.right; this.parent = splayTreeNode.parent; } } public boolean isNull() { return (this.value == null && this.left == null && this.right == null && this.parent == null); } public SplayTreeNode(String v) { left = right = parent = null; value = v; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class SplayTree { public SplayTreeNode root; /** * Core Functions */ public void insert(String value) { SplayTreeNode n = new SplayTreeNode(value); insertSplayTree(this.root, n); } /** * Insert new node */ private void insertSplayTree(SplayTreeNode currentNode, SplayTreeNode newNode) { if (currentNode == null) { this.root = newNode; } else { if (newNode.value.compareTo(currentNode.value) 0) { if (currentNode.right == null) { currentNode.right = newNode; newNode.parent = currentNode; } else { insertSplayTree(currentNode.right, newNode); } } else { System.out.println(\"\\nValue \" + newNode.value + \" already exists. Ignoring...\"); } } } /** * Finds a node */ public SplayTreeNode find(String value) { SplayTreeNode result = find(this.root, value); if (result != null) { while (result.parent != null) { if (result.parent.parent == null) { // single rotations if (result.parent.left != null && result.parent.left.equals(result)) { // zig rotation result = zig(result); } else if (result.parent.right != null && result.parent.right.equals(result)) { // zag rotation result = zag(result); } } else { // double rotations if (result.parent.parent.left != null && result.parent.parent.left.left != null && result.parent.parent.left.left.equals(result)) { // zig-zig rotation result = zigZig(result); } else if (result.parent.parent.left != null && result.parent.parent.left.right != null && result.parent.parent.left.right.equals(result)) { // zag-zig rotation result = zagZig(result); } else if (result.parent.parent.right != null && result.parent.parent.right.left != null && result.parent.parent.right.left.equals(result)) { // zig-zag rotation result = zigZag(result); } else if (result.parent.parent.right != null && result.parent.parent.right.right != null && result.parent.parent.right.right.equals(result)) { // zag-zag rotation result = zagZag(result); } } } } if (result != null) { this.root = result; } return result; } /** * Finds a node */ public SplayTreeNode find(SplayTreeNode currentNode, String value) { if (value.equals(currentNode.value)) return currentNode; else if (currentNode.left != null || currentNode.right != null) { if (currentNode.left != null) { if (value.equals(currentNode.value)) return currentNode; else if (value.compareTo(currentNode.value) 0) return find(currentNode.right, value); else if (currentNode.left != null) return find(currentNode.left, value); else return null; } else { return null; } } /** * Rotation left to right */ private SplayTreeNode zig(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node); SplayTreeNode a = new SplayTreeNode(node.left); SplayTreeNode b = new SplayTreeNode(node.right); if (a.isNull()) a.parent = k1; if (b.isNull()) b.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node.parent); SplayTreeNode k2Parent = k2.parent; SplayTreeNode c = new SplayTreeNode(node.parent.right); if (c.isNull()) c.parent = k2; k2.left = b; k1.right = k2; b.parent = k2; k2.parent = k1; node = k1; node.parent = k2Parent; if (node.parent != null) { node.parent.left = node; } return node; } /** * Rotation right to left */ private SplayTreeNode zag(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node.parent); SplayTreeNode k1Parent = k1.parent; SplayTreeNode a = new SplayTreeNode(node.parent.left); if (a.isNull()) a.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node); SplayTreeNode b = new SplayTreeNode(node.left); SplayTreeNode c = new SplayTreeNode(node.right); if (b.isNull()) b.parent = k2; if (c.isNull()) c.parent = k2; k1.right = b; k2.left = k1; b.parent = k1; k1.parent = k2; node = k2; node.parent = k1Parent; if (node.parent != null) { node.parent.right = node; } return node; } /** * Double rotation left to right */ private SplayTreeNode zigZag(SplayTreeNode node) { return null; } /** * Double rotation right to left */ private SplayTreeNode zagZig(SplayTreeNode node) { return null; } /** * Double rotation left to left */ private SplayTreeNode zigZig(SplayTreeNode node) { return null; } /** * Double rotation right to right */ private SplayTreeNode zagZag(SplayTreeNode node) { SplayTreeNode k1 = new SplayTreeNode(node.parent.parent); SplayTreeNode k1Parent = k1.parent; SplayTreeNode a = new SplayTreeNode(node.parent.parent.left); if (a.isNull()) a.parent = k1; SplayTreeNode k2 = new SplayTreeNode(node.parent); SplayTreeNode b = new SplayTreeNode(node.parent.left); if (b.isNull()) b.parent = k2; SplayTreeNode k3 = new SplayTreeNode(node); SplayTreeNode c = new SplayTreeNode(node.left); SplayTreeNode d = new SplayTreeNode(node.right); if (c.isNull()) c.parent = k3; if (d.isNull()) d.parent = k3; k1.left = a; k1.right = b; k2.left = k1; k2.right = c; k3.left = k2; k3.right = d; k3.parent = k1Parent; k1.parent = k2; k2.parent = k3; b.parent = k1; c.parent = k2; node = k3; if (node.parent != null) { node.parent.right = node; } return node; } /** * Removes a node from the tree * * @hash is just to print index in table hash */ public void remove() { removeSplayTree(this.root); } /** * Removes the node from the top.. */ private void removeSplayTree(SplayTreeNode startingNode) { } /** * Helper Functions */ public SplayTreeNode top() { return this.root; } public int height() { return height(this.root); } /** * Calculating the height of a node. */ private int height(SplayTreeNode currentNode) { if (currentNode == null) { return -1; } if (currentNode.left == null && currentNode.right == null) { return 1; } else if (currentNode.left == null) { return 1 + height(currentNode.right); } else if (currentNode.right == null) { return 1 + height(currentNode.left); } else { return 1 + maximum(height(currentNode.left), height(currentNode.right)); } } /** * Return the maximum of two integers. */ private int maximum(int a, int b) { if (a = b) { return a; } else { return b; } } /** * Calculates the Inorder traversal of this tree. */ public ArrayList inOrder() { ArrayList ret = new ArrayList (); inOrder(root, ret); return ret; } /** * Function to calculate in order recursively. */ private void inOrder(SplayTreeNode node, ArrayList io) { if (node == null) { return; } inOrder(node.left, io); io.add(node); inOrder(node.right, io); } } Using this code with these entries Element[] SET = {new Element(\"03\"), new Element(\"08\"), new Element(\"17\"), new Element(\"04\"), new Element(\"29\"), new Element(\"36\"), new Element(\"49\"), new Element(\"18\"), new Element(\"12\"), new Element(\"07\"), new Element(\"23\"), new Element(\"52\"), new Element(\"48\"), new Element(\"11\"), new Element(\"32\")} will produce the following result: After searching 17 After searching 52 Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","date":"2015-01-14T03:13:06.000Z","path":"splay-tree"},{"title":"Trees","image":"http://i.imgur.com/1mMV9xR.jpg","tags":["java","tree"],"content":"Tree is a very commonly used abstract data type (ADT) and one of the most powerful of the advanced data structures. A tree structure is basically with a root value (initial node) and subtrees of children, represented as a set of linked nodes. To understand the Tree Concept, some definitions must be remembered: Let's consider this image: Root is called the node without parent, the initial node. In our example this is node \"04\". Leaf is a node without children. In our example \"01\", \"03\" and \"06\". Internal nodes are the nodes, which are not leaf or root. \"02\" and \"05\". Depth of a node is the length of the path from the root to certain node. In our example \"04\" has depth zero because it's the root, \"05\" has depth one and \"03\" has depth two. Height of tree is the maximum depth of all its nodes. In our example the tree height is 2. A Tree can be defined recursively as a collection of nodes, starting at a root node, where each node is a data structure consisting of a value, together with a list of references to descendant nodes, the \"children\", with the constraints that no reference is duplicated, and none points to the root. The following statements are true for trees: Each node can have 0 or more direct descendants (children). Each node has at most one parent, except the root. All nodes are reachable from the root. Below there are links to all implementations of several applications of Trees concept. Avl Tree Leftist Tree Fibonacci Heap Splay Tree","date":"2015-01-13T22:27:37.000Z","path":"trees"}]